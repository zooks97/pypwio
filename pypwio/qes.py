#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Aug 28 11:14:42 2018 by generateDS.py version 2.29.24.
# Python 3.6.6 |Anaconda, Inc.| (default, Jun 28 2018, 17:14:51)  [GCC 7.2.0]
#
# Command line options:
#   ('-f', '')
#   ('-o', 'qes-1.0.py')
#
# Command line arguments:
#   qes-1.0.xsd
#
# Command line:
#   /home/azadoks/.local/miniconda3/envs/dftman/bin/generateDS -f -o "qes-1.0.py" qes-1.0.xsd
#
# Current working directory (os.getcwd()):
#   xml
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class HubbardProjType(object):
    ATOMIC='atomic'
    ORTHOATOMIC='ortho-atomic'
    NORMATOMIC='norm-atomic'
    PSEUDO='pseudo'
    FILE='file'


class calculationType(object):
    SCF='scf'
    NSCF='nscf'
    BANDS='bands'
    RELAX='relax'
    VCRELAX='vc-relax'
    MD='md'
    VCMD='vc-md'


class constr_typeType(object):
    TYPE_COORD='type_coord'
    ATOM_COORD='atom_coord'
    DISTANCE='distance'
    PLANAR_ANGLE='planar_angle'
    TORSIONAL_ANGLE='torsional_angle'
    BENNET_PROJ='bennet_proj'


class controlRestartModeType(object):
    FROM_SCRATCH='from_scratch'
    RESTART='restart'


class diagoType(object):
    DAVIDSON='davidson'
    CG='cg'


class electric_potentialType(object):
    SAWTOOTH_POTENTIAL='sawtooth_potential'
    HOMOGENOUS_FIELD='homogenous_field'
    BERRY__PHASE='Berry_Phase'
    NONE='none'


class functionalType(object):
    PZ='PZ'
    BP='BP'
    PBE='PBE'
    REVPBE='REVPBE'
    PBESOL='PBESOL'
    BLYP='BLYP'
    OLYP='OLYP'
    PW_91='PW91'
    WC='WC'
    SOGGA='SOGGA'
    EV_93='EV93'
    B_3_LYP='B3LYP'
    GAU_PBE='GauPBE'
    PBE_0='PBE0'
    HSE='HSE'
    VDWDF='VDW-DF'
    VDWDFCX='VDW-DF-CX'
    VDWDFC_09='VDW-DF-C09'
    VDWDFOB_86='VDW-DF-OB86'
    VDWDFOBK_8='VDW-DF-OBK8'
    VDWDF_2='VDW-DF2'
    VDWDF_2C_09='VDW-DF2-C09'
    VDWDF_2B_86_R='VDW-DF2-B86R'
    RVV_10='RVV10'


class lowhighType(object):
    LOW='low'
    HIGH='high'


class mixingModeType(object):
    PLAIN='plain'
    TF='TF'
    LOCALTF='local-TF'


class smearingChoiceType(object):
    GAUSSIAN='gaussian'
    MP='mp'
    MV='mv'
    FD='fd'


class statusType(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _2_55='255'


class espressoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Units=None, general_info=None, parallel_info=None, input=None, step=None, output=None, status=None, cputime=None, closed=None):
        self.original_tagname_ = None
        self.Units = _cast(None, Units)
        self.general_info = general_info
        self.parallel_info = parallel_info
        self.input = input
        if step is None:
            self.step = []
        else:
            self.step = step
        self.output = output
        self.status = status
        self.validate_statusType(self.status)
        self.cputime = cputime
        self.closed = closed
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, espressoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if espressoType.subclass:
            return espressoType.subclass(*args_, **kwargs_)
        else:
            return espressoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_general_info(self): return self.general_info
    def set_general_info(self, general_info): self.general_info = general_info
    def get_parallel_info(self): return self.parallel_info
    def set_parallel_info(self, parallel_info): self.parallel_info = parallel_info
    def get_input(self): return self.input
    def set_input(self, input): self.input = input
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def add_step(self, value): self.step.append(value)
    def insert_step_at(self, index, value): self.step.insert(index, value)
    def replace_step_at(self, index, value): self.step[index] = value
    def get_output(self): return self.output
    def set_output(self, output): self.output = output
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_cputime(self): return self.cputime
    def set_cputime(self, cputime): self.cputime = cputime
    def get_closed(self): return self.closed
    def set_closed(self, closed): self.closed = closed
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def validate_statusType(self, value):
        # Validate type statusType, a restriction on integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '255']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on statusType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.general_info is not None or
            self.parallel_info is not None or
            self.input is not None or
            self.step or
            self.output is not None or
            self.status is not None or
            self.cputime is not None or
            self.closed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='espressoType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('espressoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='espressoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='espressoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='espressoType'):
        if self.Units is not None and 'Units' not in already_processed:
            already_processed.add('Units')
            outfile.write(' Units=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Units), input_name='Units')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='espressoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.general_info is not None:
            self.general_info.export(outfile, level, namespaceprefix_, name_='general_info', pretty_print=pretty_print)
        if self.parallel_info is not None:
            self.parallel_info.export(outfile, level, namespaceprefix_, name_='parallel_info', pretty_print=pretty_print)
        if self.input is not None:
            self.input.export(outfile, level, namespaceprefix_, name_='input', pretty_print=pretty_print)
        for step_ in self.step:
            step_.export(outfile, level, namespaceprefix_, name_='step', pretty_print=pretty_print)
        if self.output is not None:
            self.output.export(outfile, level, namespaceprefix_, name_='output', pretty_print=pretty_print)
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:status>%s</qes:status>%s' % (self.gds_format_integer(self.status, input_name='status'), eol_))
        if self.cputime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:cputime>%s</qes:cputime>%s' % (self.gds_format_integer(self.cputime, input_name='cputime'), eol_))
        if self.closed is not None:
            self.closed.export(outfile, level, namespaceprefix_, name_='closed', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Units', node)
        if value is not None and 'Units' not in already_processed:
            already_processed.add('Units')
            self.Units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'general_info':
            obj_ = general_infoType.factory()
            obj_.build(child_)
            self.general_info = obj_
            obj_.original_tagname_ = 'general_info'
        elif nodeName_ == 'parallel_info':
            obj_ = parallel_infoType.factory()
            obj_.build(child_)
            self.parallel_info = obj_
            obj_.original_tagname_ = 'parallel_info'
        elif nodeName_ == 'input':
            obj_ = inputType.factory()
            obj_.build(child_)
            self.input = obj_
            obj_.original_tagname_ = 'input'
        elif nodeName_ == 'step':
            obj_ = stepType.factory()
            obj_.build(child_)
            self.step.append(obj_)
            obj_.original_tagname_ = 'step'
        elif nodeName_ == 'output':
            obj_ = outputType.factory()
            obj_.build(child_)
            self.output = obj_
            obj_.original_tagname_ = 'output'
        elif nodeName_ == 'status' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'status')
            self.status = ival_
            # validate type statusType
            self.validate_statusType(self.status)
        elif nodeName_ == 'cputime' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'cputime')
            self.cputime = ival_
        elif nodeName_ == 'closed':
            obj_ = closedType.factory()
            obj_.build(child_)
            self.closed = obj_
            obj_.original_tagname_ = 'closed'
# end class espressoType


class general_infoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, xml_format=None, creator=None, created=None, job=None):
        self.original_tagname_ = None
        self.xml_format = xml_format
        self.creator = creator
        self.created = created
        self.job = job
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, general_infoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if general_infoType.subclass:
            return general_infoType.subclass(*args_, **kwargs_)
        else:
            return general_infoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xml_format(self): return self.xml_format
    def set_xml_format(self, xml_format): self.xml_format = xml_format
    def get_creator(self): return self.creator
    def set_creator(self, creator): self.creator = creator
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def get_job(self): return self.job
    def set_job(self, job): self.job = job
    def hasContent_(self):
        if (
            self.xml_format is not None or
            self.creator is not None or
            self.created is not None or
            self.job is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='general_infoType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('general_infoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='general_infoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='general_infoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='general_infoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='general_infoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xml_format is not None:
            self.xml_format.export(outfile, level, namespaceprefix_, name_='xml_format', pretty_print=pretty_print)
        if self.creator is not None:
            self.creator.export(outfile, level, namespaceprefix_, name_='creator', pretty_print=pretty_print)
        if self.created is not None:
            self.created.export(outfile, level, namespaceprefix_, name_='created', pretty_print=pretty_print)
        if self.job is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:job>%s</qes:job>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.job), input_name='job')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xml_format':
            obj_ = xml_formatType.factory()
            obj_.build(child_)
            self.xml_format = obj_
            obj_.original_tagname_ = 'xml_format'
        elif nodeName_ == 'creator':
            obj_ = creatorType.factory()
            obj_.build(child_)
            self.creator = obj_
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'created':
            obj_ = createdType.factory()
            obj_.build(child_)
            self.created = obj_
            obj_.original_tagname_ = 'created'
        elif nodeName_ == 'job':
            job_ = child_.text
            job_ = self.gds_validate_string(job_, node, 'job')
            self.job = job_
# end class general_infoType


class parallel_infoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nprocs=None, nthreads=None, ntasks=None, nbgrp=None, npool=None, ndiag=None):
        self.original_tagname_ = None
        self.nprocs = nprocs
        self.nthreads = nthreads
        self.ntasks = ntasks
        self.nbgrp = nbgrp
        self.npool = npool
        self.ndiag = ndiag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parallel_infoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parallel_infoType.subclass:
            return parallel_infoType.subclass(*args_, **kwargs_)
        else:
            return parallel_infoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nprocs(self): return self.nprocs
    def set_nprocs(self, nprocs): self.nprocs = nprocs
    def get_nthreads(self): return self.nthreads
    def set_nthreads(self, nthreads): self.nthreads = nthreads
    def get_ntasks(self): return self.ntasks
    def set_ntasks(self, ntasks): self.ntasks = ntasks
    def get_nbgrp(self): return self.nbgrp
    def set_nbgrp(self, nbgrp): self.nbgrp = nbgrp
    def get_npool(self): return self.npool
    def set_npool(self, npool): self.npool = npool
    def get_ndiag(self): return self.ndiag
    def set_ndiag(self, ndiag): self.ndiag = ndiag
    def hasContent_(self):
        if (
            self.nprocs is not None or
            self.nthreads is not None or
            self.ntasks is not None or
            self.nbgrp is not None or
            self.npool is not None or
            self.ndiag is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='parallel_infoType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parallel_infoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parallel_infoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='parallel_infoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='parallel_infoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='parallel_infoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nprocs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nprocs>%s</qes:nprocs>%s' % (self.gds_format_integer(self.nprocs, input_name='nprocs'), eol_))
        if self.nthreads is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nthreads>%s</qes:nthreads>%s' % (self.gds_format_integer(self.nthreads, input_name='nthreads'), eol_))
        if self.ntasks is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ntasks>%s</qes:ntasks>%s' % (self.gds_format_integer(self.ntasks, input_name='ntasks'), eol_))
        if self.nbgrp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nbgrp>%s</qes:nbgrp>%s' % (self.gds_format_integer(self.nbgrp, input_name='nbgrp'), eol_))
        if self.npool is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:npool>%s</qes:npool>%s' % (self.gds_format_integer(self.npool, input_name='npool'), eol_))
        if self.ndiag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ndiag>%s</qes:ndiag>%s' % (self.gds_format_integer(self.ndiag, input_name='ndiag'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nprocs' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nprocs')
            self.nprocs = ival_
        elif nodeName_ == 'nthreads' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nthreads')
            self.nthreads = ival_
        elif nodeName_ == 'ntasks' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ntasks')
            self.ntasks = ival_
        elif nodeName_ == 'nbgrp' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nbgrp')
            self.nbgrp = ival_
        elif nodeName_ == 'npool' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'npool')
            self.npool = ival_
        elif nodeName_ == 'ndiag' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ndiag')
            self.ndiag = ival_
# end class parallel_infoType


class inputType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, control_variables=None, atomic_species=None, atomic_structure=None, dft=None, spin=None, bands=None, basis=None, electron_control=None, k_points_IBZ=None, ion_control=None, cell_control=None, symmetry_flags=None, boundary_conditions=None, ekin_functional=None, external_atomic_forces=None, free_positions=None, starting_atomic_velocities=None, electric_field=None, atomic_constraints=None, spin_constraints=None):
        self.original_tagname_ = None
        self.control_variables = control_variables
        self.atomic_species = atomic_species
        self.atomic_structure = atomic_structure
        self.dft = dft
        self.spin = spin
        self.bands = bands
        self.basis = basis
        self.electron_control = electron_control
        self.k_points_IBZ = k_points_IBZ
        self.ion_control = ion_control
        self.cell_control = cell_control
        self.symmetry_flags = symmetry_flags
        self.boundary_conditions = boundary_conditions
        self.ekin_functional = ekin_functional
        self.external_atomic_forces = external_atomic_forces
        self.free_positions = free_positions
        self.starting_atomic_velocities = starting_atomic_velocities
        self.electric_field = electric_field
        self.atomic_constraints = atomic_constraints
        self.spin_constraints = spin_constraints
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, inputType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if inputType.subclass:
            return inputType.subclass(*args_, **kwargs_)
        else:
            return inputType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_control_variables(self): return self.control_variables
    def set_control_variables(self, control_variables): self.control_variables = control_variables
    def get_atomic_species(self): return self.atomic_species
    def set_atomic_species(self, atomic_species): self.atomic_species = atomic_species
    def get_atomic_structure(self): return self.atomic_structure
    def set_atomic_structure(self, atomic_structure): self.atomic_structure = atomic_structure
    def get_dft(self): return self.dft
    def set_dft(self, dft): self.dft = dft
    def get_spin(self): return self.spin
    def set_spin(self, spin): self.spin = spin
    def get_bands(self): return self.bands
    def set_bands(self, bands): self.bands = bands
    def get_basis(self): return self.basis
    def set_basis(self, basis): self.basis = basis
    def get_electron_control(self): return self.electron_control
    def set_electron_control(self, electron_control): self.electron_control = electron_control
    def get_k_points_IBZ(self): return self.k_points_IBZ
    def set_k_points_IBZ(self, k_points_IBZ): self.k_points_IBZ = k_points_IBZ
    def get_ion_control(self): return self.ion_control
    def set_ion_control(self, ion_control): self.ion_control = ion_control
    def get_cell_control(self): return self.cell_control
    def set_cell_control(self, cell_control): self.cell_control = cell_control
    def get_symmetry_flags(self): return self.symmetry_flags
    def set_symmetry_flags(self, symmetry_flags): self.symmetry_flags = symmetry_flags
    def get_boundary_conditions(self): return self.boundary_conditions
    def set_boundary_conditions(self, boundary_conditions): self.boundary_conditions = boundary_conditions
    def get_ekin_functional(self): return self.ekin_functional
    def set_ekin_functional(self, ekin_functional): self.ekin_functional = ekin_functional
    def get_external_atomic_forces(self): return self.external_atomic_forces
    def set_external_atomic_forces(self, external_atomic_forces): self.external_atomic_forces = external_atomic_forces
    def get_free_positions(self): return self.free_positions
    def set_free_positions(self, free_positions): self.free_positions = free_positions
    def get_starting_atomic_velocities(self): return self.starting_atomic_velocities
    def set_starting_atomic_velocities(self, starting_atomic_velocities): self.starting_atomic_velocities = starting_atomic_velocities
    def get_electric_field(self): return self.electric_field
    def set_electric_field(self, electric_field): self.electric_field = electric_field
    def get_atomic_constraints(self): return self.atomic_constraints
    def set_atomic_constraints(self, atomic_constraints): self.atomic_constraints = atomic_constraints
    def get_spin_constraints(self): return self.spin_constraints
    def set_spin_constraints(self, spin_constraints): self.spin_constraints = spin_constraints
    def hasContent_(self):
        if (
            self.control_variables is not None or
            self.atomic_species is not None or
            self.atomic_structure is not None or
            self.dft is not None or
            self.spin is not None or
            self.bands is not None or
            self.basis is not None or
            self.electron_control is not None or
            self.k_points_IBZ is not None or
            self.ion_control is not None or
            self.cell_control is not None or
            self.symmetry_flags is not None or
            self.boundary_conditions is not None or
            self.ekin_functional is not None or
            self.external_atomic_forces is not None or
            self.free_positions is not None or
            self.starting_atomic_velocities is not None or
            self.electric_field is not None or
            self.atomic_constraints is not None or
            self.spin_constraints is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='inputType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('inputType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='inputType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='inputType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='inputType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='inputType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.control_variables is not None:
            self.control_variables.export(outfile, level, namespaceprefix_, name_='control_variables', pretty_print=pretty_print)
        if self.atomic_species is not None:
            self.atomic_species.export(outfile, level, namespaceprefix_, name_='atomic_species', pretty_print=pretty_print)
        if self.atomic_structure is not None:
            self.atomic_structure.export(outfile, level, namespaceprefix_, name_='atomic_structure', pretty_print=pretty_print)
        if self.dft is not None:
            self.dft.export(outfile, level, namespaceprefix_, name_='dft', pretty_print=pretty_print)
        if self.spin is not None:
            self.spin.export(outfile, level, namespaceprefix_, name_='spin', pretty_print=pretty_print)
        if self.bands is not None:
            self.bands.export(outfile, level, namespaceprefix_, name_='bands', pretty_print=pretty_print)
        if self.basis is not None:
            self.basis.export(outfile, level, namespaceprefix_, name_='basis', pretty_print=pretty_print)
        if self.electron_control is not None:
            self.electron_control.export(outfile, level, namespaceprefix_, name_='electron_control', pretty_print=pretty_print)
        if self.k_points_IBZ is not None:
            self.k_points_IBZ.export(outfile, level, namespaceprefix_, name_='k_points_IBZ', pretty_print=pretty_print)
        if self.ion_control is not None:
            self.ion_control.export(outfile, level, namespaceprefix_, name_='ion_control', pretty_print=pretty_print)
        if self.cell_control is not None:
            self.cell_control.export(outfile, level, namespaceprefix_, name_='cell_control', pretty_print=pretty_print)
        if self.symmetry_flags is not None:
            self.symmetry_flags.export(outfile, level, namespaceprefix_, name_='symmetry_flags', pretty_print=pretty_print)
        if self.boundary_conditions is not None:
            self.boundary_conditions.export(outfile, level, namespaceprefix_, name_='boundary_conditions', pretty_print=pretty_print)
        if self.ekin_functional is not None:
            self.ekin_functional.export(outfile, level, namespaceprefix_, name_='ekin_functional', pretty_print=pretty_print)
        if self.external_atomic_forces is not None:
            self.external_atomic_forces.export(outfile, level, namespaceprefix_, name_='external_atomic_forces', pretty_print=pretty_print)
        if self.free_positions is not None:
            self.free_positions.export(outfile, level, namespaceprefix_, name_='free_positions', pretty_print=pretty_print)
        if self.starting_atomic_velocities is not None:
            self.starting_atomic_velocities.export(outfile, level, namespaceprefix_, name_='starting_atomic_velocities', pretty_print=pretty_print)
        if self.electric_field is not None:
            self.electric_field.export(outfile, level, namespaceprefix_, name_='electric_field', pretty_print=pretty_print)
        if self.atomic_constraints is not None:
            self.atomic_constraints.export(outfile, level, namespaceprefix_, name_='atomic_constraints', pretty_print=pretty_print)
        if self.spin_constraints is not None:
            self.spin_constraints.export(outfile, level, namespaceprefix_, name_='spin_constraints', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'control_variables':
            obj_ = control_variablesType.factory()
            obj_.build(child_)
            self.control_variables = obj_
            obj_.original_tagname_ = 'control_variables'
        elif nodeName_ == 'atomic_species':
            obj_ = atomic_speciesType.factory()
            obj_.build(child_)
            self.atomic_species = obj_
            obj_.original_tagname_ = 'atomic_species'
        elif nodeName_ == 'atomic_structure':
            obj_ = atomic_structureType.factory()
            obj_.build(child_)
            self.atomic_structure = obj_
            obj_.original_tagname_ = 'atomic_structure'
        elif nodeName_ == 'dft':
            obj_ = dftType.factory()
            obj_.build(child_)
            self.dft = obj_
            obj_.original_tagname_ = 'dft'
        elif nodeName_ == 'spin':
            obj_ = spinType.factory()
            obj_.build(child_)
            self.spin = obj_
            obj_.original_tagname_ = 'spin'
        elif nodeName_ == 'bands':
            obj_ = bandsType.factory()
            obj_.build(child_)
            self.bands = obj_
            obj_.original_tagname_ = 'bands'
        elif nodeName_ == 'basis':
            obj_ = basisType.factory()
            obj_.build(child_)
            self.basis = obj_
            obj_.original_tagname_ = 'basis'
        elif nodeName_ == 'electron_control':
            obj_ = electron_controlType.factory()
            obj_.build(child_)
            self.electron_control = obj_
            obj_.original_tagname_ = 'electron_control'
        elif nodeName_ == 'k_points_IBZ':
            obj_ = k_points_IBZType.factory()
            obj_.build(child_)
            self.k_points_IBZ = obj_
            obj_.original_tagname_ = 'k_points_IBZ'
        elif nodeName_ == 'ion_control':
            obj_ = ion_controlType.factory()
            obj_.build(child_)
            self.ion_control = obj_
            obj_.original_tagname_ = 'ion_control'
        elif nodeName_ == 'cell_control':
            obj_ = cell_controlType.factory()
            obj_.build(child_)
            self.cell_control = obj_
            obj_.original_tagname_ = 'cell_control'
        elif nodeName_ == 'symmetry_flags':
            obj_ = symmetry_flagsType.factory()
            obj_.build(child_)
            self.symmetry_flags = obj_
            obj_.original_tagname_ = 'symmetry_flags'
        elif nodeName_ == 'boundary_conditions':
            obj_ = boundary_conditionsType.factory()
            obj_.build(child_)
            self.boundary_conditions = obj_
            obj_.original_tagname_ = 'boundary_conditions'
        elif nodeName_ == 'ekin_functional':
            obj_ = ekin_functionalType.factory()
            obj_.build(child_)
            self.ekin_functional = obj_
            obj_.original_tagname_ = 'ekin_functional'
        elif nodeName_ == 'external_atomic_forces':
            class_obj_ = self.get_class_obj_(child_, matrixType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.external_atomic_forces = obj_
            obj_.original_tagname_ = 'external_atomic_forces'
        elif nodeName_ == 'free_positions':
            obj_ = integerMatrixType.factory()
            obj_.build(child_)
            self.free_positions = obj_
            obj_.original_tagname_ = 'free_positions'
        elif nodeName_ == 'starting_atomic_velocities':
            class_obj_ = self.get_class_obj_(child_, matrixType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.starting_atomic_velocities = obj_
            obj_.original_tagname_ = 'starting_atomic_velocities'
        elif nodeName_ == 'electric_field':
            obj_ = electric_fieldType.factory()
            obj_.build(child_)
            self.electric_field = obj_
            obj_.original_tagname_ = 'electric_field'
        elif nodeName_ == 'atomic_constraints':
            obj_ = atomic_constraintsType.factory()
            obj_.build(child_)
            self.atomic_constraints = obj_
            obj_.original_tagname_ = 'atomic_constraints'
        elif nodeName_ == 'spin_constraints':
            obj_ = spin_constraintsType.factory()
            obj_.build(child_)
            self.spin_constraints = obj_
            obj_.original_tagname_ = 'spin_constraints'
# end class inputType


class stepType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, n_step=None, scf_conv=None, atomic_structure=None, total_energy=None, forces=None, stress=None, FCP_force=None, FCP_tot_charge=None):
        self.original_tagname_ = None
        self.n_step = _cast(int, n_step)
        self.scf_conv = scf_conv
        self.atomic_structure = atomic_structure
        self.total_energy = total_energy
        self.forces = forces
        self.stress = stress
        self.FCP_force = FCP_force
        self.FCP_tot_charge = FCP_tot_charge
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stepType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stepType.subclass:
            return stepType.subclass(*args_, **kwargs_)
        else:
            return stepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scf_conv(self): return self.scf_conv
    def set_scf_conv(self, scf_conv): self.scf_conv = scf_conv
    def get_atomic_structure(self): return self.atomic_structure
    def set_atomic_structure(self, atomic_structure): self.atomic_structure = atomic_structure
    def get_total_energy(self): return self.total_energy
    def set_total_energy(self, total_energy): self.total_energy = total_energy
    def get_forces(self): return self.forces
    def set_forces(self, forces): self.forces = forces
    def get_stress(self): return self.stress
    def set_stress(self, stress): self.stress = stress
    def get_FCP_force(self): return self.FCP_force
    def set_FCP_force(self, FCP_force): self.FCP_force = FCP_force
    def get_FCP_tot_charge(self): return self.FCP_tot_charge
    def set_FCP_tot_charge(self, FCP_tot_charge): self.FCP_tot_charge = FCP_tot_charge
    def get_n_step(self): return self.n_step
    def set_n_step(self, n_step): self.n_step = n_step
    def hasContent_(self):
        if (
            self.scf_conv is not None or
            self.atomic_structure is not None or
            self.total_energy is not None or
            self.forces is not None or
            self.stress is not None or
            self.FCP_force is not None or
            self.FCP_tot_charge is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='stepType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stepType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stepType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='stepType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='stepType'):
        if self.n_step is not None and 'n_step' not in already_processed:
            already_processed.add('n_step')
            outfile.write(' n_step="%s"' % self.gds_format_integer(self.n_step, input_name='n_step'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='stepType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.scf_conv is not None:
            self.scf_conv.export(outfile, level, namespaceprefix_, name_='scf_conv', pretty_print=pretty_print)
        if self.atomic_structure is not None:
            self.atomic_structure.export(outfile, level, namespaceprefix_, name_='atomic_structure', pretty_print=pretty_print)
        if self.total_energy is not None:
            self.total_energy.export(outfile, level, namespaceprefix_, name_='total_energy', pretty_print=pretty_print)
        if self.forces is not None:
            self.forces.export(outfile, level, namespaceprefix_, name_='forces', pretty_print=pretty_print)
        if self.stress is not None:
            self.stress.export(outfile, level, namespaceprefix_, name_='stress', pretty_print=pretty_print)
        if self.FCP_force is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:FCP_force>%s</qes:FCP_force>%s' % (self.gds_format_double(self.FCP_force, input_name='FCP_force'), eol_))
        if self.FCP_tot_charge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:FCP_tot_charge>%s</qes:FCP_tot_charge>%s' % (self.gds_format_double(self.FCP_tot_charge, input_name='FCP_tot_charge'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('n_step', node)
        if value is not None and 'n_step' not in already_processed:
            already_processed.add('n_step')
            try:
                self.n_step = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.n_step <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scf_conv':
            obj_ = scf_convType.factory()
            obj_.build(child_)
            self.scf_conv = obj_
            obj_.original_tagname_ = 'scf_conv'
        elif nodeName_ == 'atomic_structure':
            obj_ = atomic_structureType.factory()
            obj_.build(child_)
            self.atomic_structure = obj_
            obj_.original_tagname_ = 'atomic_structure'
        elif nodeName_ == 'total_energy':
            obj_ = total_energyType.factory()
            obj_.build(child_)
            self.total_energy = obj_
            obj_.original_tagname_ = 'total_energy'
        elif nodeName_ == 'forces':
            class_obj_ = self.get_class_obj_(child_, matrixType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.forces = obj_
            obj_.original_tagname_ = 'forces'
        elif nodeName_ == 'stress':
            class_obj_ = self.get_class_obj_(child_, matrixType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.stress = obj_
            obj_.original_tagname_ = 'stress'
        elif nodeName_ == 'FCP_force' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'FCP_force')
            self.FCP_force = fval_
        elif nodeName_ == 'FCP_tot_charge' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'FCP_tot_charge')
            self.FCP_tot_charge = fval_
# end class stepType


class outputType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, convergence_info=None, algorithmic_info=None, atomic_species=None, atomic_structure=None, symmetries=None, basis_set=None, dft=None, boundary_conditions=None, magnetization=None, total_energy=None, band_structure=None, forces=None, stress=None, electric_field=None, FCP_force=None, FCP_tot_charge=None):
        self.original_tagname_ = None
        self.convergence_info = convergence_info
        self.algorithmic_info = algorithmic_info
        self.atomic_species = atomic_species
        self.atomic_structure = atomic_structure
        self.symmetries = symmetries
        self.basis_set = basis_set
        self.dft = dft
        self.boundary_conditions = boundary_conditions
        self.magnetization = magnetization
        self.total_energy = total_energy
        self.band_structure = band_structure
        self.forces = forces
        self.stress = stress
        self.electric_field = electric_field
        self.FCP_force = FCP_force
        self.FCP_tot_charge = FCP_tot_charge
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, outputType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if outputType.subclass:
            return outputType.subclass(*args_, **kwargs_)
        else:
            return outputType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_convergence_info(self): return self.convergence_info
    def set_convergence_info(self, convergence_info): self.convergence_info = convergence_info
    def get_algorithmic_info(self): return self.algorithmic_info
    def set_algorithmic_info(self, algorithmic_info): self.algorithmic_info = algorithmic_info
    def get_atomic_species(self): return self.atomic_species
    def set_atomic_species(self, atomic_species): self.atomic_species = atomic_species
    def get_atomic_structure(self): return self.atomic_structure
    def set_atomic_structure(self, atomic_structure): self.atomic_structure = atomic_structure
    def get_symmetries(self): return self.symmetries
    def set_symmetries(self, symmetries): self.symmetries = symmetries
    def get_basis_set(self): return self.basis_set
    def set_basis_set(self, basis_set): self.basis_set = basis_set
    def get_dft(self): return self.dft
    def set_dft(self, dft): self.dft = dft
    def get_boundary_conditions(self): return self.boundary_conditions
    def set_boundary_conditions(self, boundary_conditions): self.boundary_conditions = boundary_conditions
    def get_magnetization(self): return self.magnetization
    def set_magnetization(self, magnetization): self.magnetization = magnetization
    def get_total_energy(self): return self.total_energy
    def set_total_energy(self, total_energy): self.total_energy = total_energy
    def get_band_structure(self): return self.band_structure
    def set_band_structure(self, band_structure): self.band_structure = band_structure
    def get_forces(self): return self.forces
    def set_forces(self, forces): self.forces = forces
    def get_stress(self): return self.stress
    def set_stress(self, stress): self.stress = stress
    def get_electric_field(self): return self.electric_field
    def set_electric_field(self, electric_field): self.electric_field = electric_field
    def get_FCP_force(self): return self.FCP_force
    def set_FCP_force(self, FCP_force): self.FCP_force = FCP_force
    def get_FCP_tot_charge(self): return self.FCP_tot_charge
    def set_FCP_tot_charge(self, FCP_tot_charge): self.FCP_tot_charge = FCP_tot_charge
    def hasContent_(self):
        if (
            self.convergence_info is not None or
            self.algorithmic_info is not None or
            self.atomic_species is not None or
            self.atomic_structure is not None or
            self.symmetries is not None or
            self.basis_set is not None or
            self.dft is not None or
            self.boundary_conditions is not None or
            self.magnetization is not None or
            self.total_energy is not None or
            self.band_structure is not None or
            self.forces is not None or
            self.stress is not None or
            self.electric_field is not None or
            self.FCP_force is not None or
            self.FCP_tot_charge is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='outputType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('outputType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='outputType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='outputType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='outputType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='outputType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.convergence_info is not None:
            self.convergence_info.export(outfile, level, namespaceprefix_, name_='convergence_info', pretty_print=pretty_print)
        if self.algorithmic_info is not None:
            self.algorithmic_info.export(outfile, level, namespaceprefix_, name_='algorithmic_info', pretty_print=pretty_print)
        if self.atomic_species is not None:
            self.atomic_species.export(outfile, level, namespaceprefix_, name_='atomic_species', pretty_print=pretty_print)
        if self.atomic_structure is not None:
            self.atomic_structure.export(outfile, level, namespaceprefix_, name_='atomic_structure', pretty_print=pretty_print)
        if self.symmetries is not None:
            self.symmetries.export(outfile, level, namespaceprefix_, name_='symmetries', pretty_print=pretty_print)
        if self.basis_set is not None:
            self.basis_set.export(outfile, level, namespaceprefix_, name_='basis_set', pretty_print=pretty_print)
        if self.dft is not None:
            self.dft.export(outfile, level, namespaceprefix_, name_='dft', pretty_print=pretty_print)
        if self.boundary_conditions is not None:
            self.boundary_conditions.export(outfile, level, namespaceprefix_, name_='boundary_conditions', pretty_print=pretty_print)
        if self.magnetization is not None:
            self.magnetization.export(outfile, level, namespaceprefix_, name_='magnetization', pretty_print=pretty_print)
        if self.total_energy is not None:
            self.total_energy.export(outfile, level, namespaceprefix_, name_='total_energy', pretty_print=pretty_print)
        if self.band_structure is not None:
            self.band_structure.export(outfile, level, namespaceprefix_, name_='band_structure', pretty_print=pretty_print)
        if self.forces is not None:
            self.forces.export(outfile, level, namespaceprefix_, name_='forces', pretty_print=pretty_print)
        if self.stress is not None:
            self.stress.export(outfile, level, namespaceprefix_, name_='stress', pretty_print=pretty_print)
        if self.electric_field is not None:
            self.electric_field.export(outfile, level, namespaceprefix_, name_='electric_field', pretty_print=pretty_print)
        if self.FCP_force is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:FCP_force>%s</qes:FCP_force>%s' % (self.gds_format_double(self.FCP_force, input_name='FCP_force'), eol_))
        if self.FCP_tot_charge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:FCP_tot_charge>%s</qes:FCP_tot_charge>%s' % (self.gds_format_double(self.FCP_tot_charge, input_name='FCP_tot_charge'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'convergence_info':
            obj_ = convergence_infoType.factory()
            obj_.build(child_)
            self.convergence_info = obj_
            obj_.original_tagname_ = 'convergence_info'
        elif nodeName_ == 'algorithmic_info':
            obj_ = algorithmic_infoType.factory()
            obj_.build(child_)
            self.algorithmic_info = obj_
            obj_.original_tagname_ = 'algorithmic_info'
        elif nodeName_ == 'atomic_species':
            obj_ = atomic_speciesType.factory()
            obj_.build(child_)
            self.atomic_species = obj_
            obj_.original_tagname_ = 'atomic_species'
        elif nodeName_ == 'atomic_structure':
            obj_ = atomic_structureType.factory()
            obj_.build(child_)
            self.atomic_structure = obj_
            obj_.original_tagname_ = 'atomic_structure'
        elif nodeName_ == 'symmetries':
            obj_ = symmetriesType.factory()
            obj_.build(child_)
            self.symmetries = obj_
            obj_.original_tagname_ = 'symmetries'
        elif nodeName_ == 'basis_set':
            obj_ = basis_setType.factory()
            obj_.build(child_)
            self.basis_set = obj_
            obj_.original_tagname_ = 'basis_set'
        elif nodeName_ == 'dft':
            obj_ = dftType.factory()
            obj_.build(child_)
            self.dft = obj_
            obj_.original_tagname_ = 'dft'
        elif nodeName_ == 'boundary_conditions':
            obj_ = outputPBCType.factory()
            obj_.build(child_)
            self.boundary_conditions = obj_
            obj_.original_tagname_ = 'boundary_conditions'
        elif nodeName_ == 'magnetization':
            obj_ = magnetizationType.factory()
            obj_.build(child_)
            self.magnetization = obj_
            obj_.original_tagname_ = 'magnetization'
        elif nodeName_ == 'total_energy':
            obj_ = total_energyType.factory()
            obj_.build(child_)
            self.total_energy = obj_
            obj_.original_tagname_ = 'total_energy'
        elif nodeName_ == 'band_structure':
            obj_ = band_structureType.factory()
            obj_.build(child_)
            self.band_structure = obj_
            obj_.original_tagname_ = 'band_structure'
        elif nodeName_ == 'forces':
            class_obj_ = self.get_class_obj_(child_, matrixType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.forces = obj_
            obj_.original_tagname_ = 'forces'
        elif nodeName_ == 'stress':
            class_obj_ = self.get_class_obj_(child_, matrixType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.stress = obj_
            obj_.original_tagname_ = 'stress'
        elif nodeName_ == 'electric_field':
            obj_ = outputElectricFieldType.factory()
            obj_.build(child_)
            self.electric_field = obj_
            obj_.original_tagname_ = 'electric_field'
        elif nodeName_ == 'FCP_force' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'FCP_force')
            self.FCP_force = fval_
        elif nodeName_ == 'FCP_tot_charge' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'FCP_tot_charge')
            self.FCP_tot_charge = fval_
# end class outputType


class control_variablesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, calculation='scf', restart_mode='from_scratch', prefix=None, pseudo_dir=None, outdir=None, stress=None, forces=None, wf_collect=False, disk_io='low', max_seconds=None, nstep=None, etot_conv_thr=1.0e-5, forc_conv_thr=1.0e-3, press_conv_thr=5e-1, verbosity='low', print_every=None):
        self.original_tagname_ = None
        self.title = title
        self.calculation = calculation
        self.validate_calculationType(self.calculation)
        self.restart_mode = restart_mode
        self.validate_controlRestartModeType(self.restart_mode)
        self.prefix = prefix
        self.pseudo_dir = pseudo_dir
        self.outdir = outdir
        self.stress = stress
        self.forces = forces
        self.wf_collect = wf_collect
        self.disk_io = disk_io
        self.validate_lowhighType(self.disk_io)
        self.max_seconds = max_seconds
        self.nstep = nstep
        self.etot_conv_thr = etot_conv_thr
        self.forc_conv_thr = forc_conv_thr
        self.press_conv_thr = press_conv_thr
        self.verbosity = verbosity
        self.validate_lowhighType(self.verbosity)
        self.print_every = print_every
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, control_variablesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if control_variablesType.subclass:
            return control_variablesType.subclass(*args_, **kwargs_)
        else:
            return control_variablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_calculation(self): return self.calculation
    def set_calculation(self, calculation): self.calculation = calculation
    def get_restart_mode(self): return self.restart_mode
    def set_restart_mode(self, restart_mode): self.restart_mode = restart_mode
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_pseudo_dir(self): return self.pseudo_dir
    def set_pseudo_dir(self, pseudo_dir): self.pseudo_dir = pseudo_dir
    def get_outdir(self): return self.outdir
    def set_outdir(self, outdir): self.outdir = outdir
    def get_stress(self): return self.stress
    def set_stress(self, stress): self.stress = stress
    def get_forces(self): return self.forces
    def set_forces(self, forces): self.forces = forces
    def get_wf_collect(self): return self.wf_collect
    def set_wf_collect(self, wf_collect): self.wf_collect = wf_collect
    def get_disk_io(self): return self.disk_io
    def set_disk_io(self, disk_io): self.disk_io = disk_io
    def get_max_seconds(self): return self.max_seconds
    def set_max_seconds(self, max_seconds): self.max_seconds = max_seconds
    def get_nstep(self): return self.nstep
    def set_nstep(self, nstep): self.nstep = nstep
    def get_etot_conv_thr(self): return self.etot_conv_thr
    def set_etot_conv_thr(self, etot_conv_thr): self.etot_conv_thr = etot_conv_thr
    def get_forc_conv_thr(self): return self.forc_conv_thr
    def set_forc_conv_thr(self, forc_conv_thr): self.forc_conv_thr = forc_conv_thr
    def get_press_conv_thr(self): return self.press_conv_thr
    def set_press_conv_thr(self, press_conv_thr): self.press_conv_thr = press_conv_thr
    def get_verbosity(self): return self.verbosity
    def set_verbosity(self, verbosity): self.verbosity = verbosity
    def get_print_every(self): return self.print_every
    def set_print_every(self, print_every): self.print_every = print_every
    def validate_calculationType(self, value):
        # Validate type calculationType, a restriction on string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['scf', 'nscf', 'bands', 'relax', 'vc-relax', 'md', 'vc-md']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on calculationType' % {"value" : value.encode("utf-8")} )
    def validate_controlRestartModeType(self, value):
        # Validate type controlRestartModeType, a restriction on string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['from_scratch', 'restart']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on controlRestartModeType' % {"value" : value.encode("utf-8")} )
    def validate_lowhighType(self, value):
        # Validate type lowhighType, a restriction on string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['low', 'high']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on lowhighType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.title is not None or
            self.calculation != "scf" or
            self.restart_mode != "from_scratch" or
            self.prefix is not None or
            self.pseudo_dir is not None or
            self.outdir is not None or
            self.stress is not None or
            self.forces is not None or
            self.wf_collect or
            self.disk_io != "low" or
            self.max_seconds is not None or
            self.nstep is not None or
            self.etot_conv_thr != 1.0e-5 or
            self.forc_conv_thr != 1.0e-3 or
            self.press_conv_thr != 5e-1 or
            self.verbosity != "low" or
            self.print_every is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='control_variablesType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('control_variablesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='control_variablesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='control_variablesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='control_variablesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='control_variablesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:title>%s</qes:title>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), eol_))
        if self.calculation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:calculation>%s</qes:calculation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.calculation), input_name='calculation')), eol_))
        if self.restart_mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:restart_mode>%s</qes:restart_mode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.restart_mode), input_name='restart_mode')), eol_))
        if self.prefix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:prefix>%s</qes:prefix>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.prefix), input_name='prefix')), eol_))
        if self.pseudo_dir is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:pseudo_dir>%s</qes:pseudo_dir>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pseudo_dir), input_name='pseudo_dir')), eol_))
        if self.outdir is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:outdir>%s</qes:outdir>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.outdir), input_name='outdir')), eol_))
        if self.stress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:stress>%s</qes:stress>%s' % (self.gds_format_boolean(self.stress, input_name='stress'), eol_))
        if self.forces is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:forces>%s</qes:forces>%s' % (self.gds_format_boolean(self.forces, input_name='forces'), eol_))
        if self.wf_collect is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:wf_collect>%s</qes:wf_collect>%s' % (self.gds_format_boolean(self.wf_collect, input_name='wf_collect'), eol_))
        if self.disk_io is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:disk_io>%s</qes:disk_io>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.disk_io), input_name='disk_io')), eol_))
        if self.max_seconds is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:max_seconds>%s</qes:max_seconds>%s' % (self.gds_format_integer(self.max_seconds, input_name='max_seconds'), eol_))
        if self.nstep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nstep>%s</qes:nstep>%s' % (self.gds_format_integer(self.nstep, input_name='nstep'), eol_))
        if self.etot_conv_thr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:etot_conv_thr>%s</qes:etot_conv_thr>%s' % (self.gds_format_double(self.etot_conv_thr, input_name='etot_conv_thr'), eol_))
        if self.forc_conv_thr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:forc_conv_thr>%s</qes:forc_conv_thr>%s' % (self.gds_format_double(self.forc_conv_thr, input_name='forc_conv_thr'), eol_))
        if self.press_conv_thr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:press_conv_thr>%s</qes:press_conv_thr>%s' % (self.gds_format_double(self.press_conv_thr, input_name='press_conv_thr'), eol_))
        if self.verbosity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:verbosity>%s</qes:verbosity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.verbosity), input_name='verbosity')), eol_))
        if self.print_every is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:print_every>%s</qes:print_every>%s' % (self.gds_format_integer(self.print_every, input_name='print_every'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'calculation':
            calculation_ = child_.text
            calculation_ = self.gds_validate_string(calculation_, node, 'calculation')
            self.calculation = calculation_
            # validate type calculationType
            self.validate_calculationType(self.calculation)
        elif nodeName_ == 'restart_mode':
            restart_mode_ = child_.text
            restart_mode_ = self.gds_validate_string(restart_mode_, node, 'restart_mode')
            self.restart_mode = restart_mode_
            # validate type controlRestartModeType
            self.validate_controlRestartModeType(self.restart_mode)
        elif nodeName_ == 'prefix':
            prefix_ = child_.text
            prefix_ = self.gds_validate_string(prefix_, node, 'prefix')
            self.prefix = prefix_
        elif nodeName_ == 'pseudo_dir':
            pseudo_dir_ = child_.text
            pseudo_dir_ = self.gds_validate_string(pseudo_dir_, node, 'pseudo_dir')
            self.pseudo_dir = pseudo_dir_
        elif nodeName_ == 'outdir':
            outdir_ = child_.text
            outdir_ = self.gds_validate_string(outdir_, node, 'outdir')
            self.outdir = outdir_
        elif nodeName_ == 'stress':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'stress')
            self.stress = ival_
        elif nodeName_ == 'forces':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'forces')
            self.forces = ival_
        elif nodeName_ == 'wf_collect':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'wf_collect')
            self.wf_collect = ival_
        elif nodeName_ == 'disk_io':
            disk_io_ = child_.text
            disk_io_ = self.gds_validate_string(disk_io_, node, 'disk_io')
            self.disk_io = disk_io_
            # validate type lowhighType
            self.validate_lowhighType(self.disk_io)
        elif nodeName_ == 'max_seconds' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'max_seconds')
            self.max_seconds = ival_
        elif nodeName_ == 'nstep' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nstep')
            self.nstep = ival_
        elif nodeName_ == 'etot_conv_thr' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'etot_conv_thr')
            self.etot_conv_thr = fval_
        elif nodeName_ == 'forc_conv_thr' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'forc_conv_thr')
            self.forc_conv_thr = fval_
        elif nodeName_ == 'press_conv_thr' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'press_conv_thr')
            self.press_conv_thr = fval_
        elif nodeName_ == 'verbosity':
            verbosity_ = child_.text
            verbosity_ = self.gds_validate_string(verbosity_, node, 'verbosity')
            self.verbosity = verbosity_
            # validate type lowhighType
            self.validate_lowhighType(self.verbosity)
        elif nodeName_ == 'print_every' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'print_every')
            self.print_every = ival_
# end class control_variablesType


class xml_formatType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NAME=None, VERSION=None, valueOf_=None):
        self.original_tagname_ = None
        self.NAME = _cast(None, NAME)
        self.VERSION = _cast(None, VERSION)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xml_formatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xml_formatType.subclass:
            return xml_formatType.subclass(*args_, **kwargs_)
        else:
            return xml_formatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_VERSION(self): return self.VERSION
    def set_VERSION(self, VERSION): self.VERSION = VERSION
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='xml_formatType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xml_formatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='xml_formatType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='xml_formatType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='xml_formatType'):
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            outfile.write(' NAME=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NAME), input_name='NAME')), ))
        if self.VERSION is not None and 'VERSION' not in already_processed:
            already_processed.add('VERSION')
            outfile.write(' VERSION=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.VERSION), input_name='VERSION')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='xml_formatType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NAME', node)
        if value is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            self.NAME = value
        value = find_attr_value_('VERSION', node)
        if value is not None and 'VERSION' not in already_processed:
            already_processed.add('VERSION')
            self.VERSION = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xml_formatType


class creatorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NAME=None, VERSION=None, valueOf_=None):
        self.original_tagname_ = None
        self.NAME = _cast(None, NAME)
        self.VERSION = _cast(None, VERSION)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, creatorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if creatorType.subclass:
            return creatorType.subclass(*args_, **kwargs_)
        else:
            return creatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_VERSION(self): return self.VERSION
    def set_VERSION(self, VERSION): self.VERSION = VERSION
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='creatorType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('creatorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='creatorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='creatorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='creatorType'):
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            outfile.write(' NAME=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NAME), input_name='NAME')), ))
        if self.VERSION is not None and 'VERSION' not in already_processed:
            already_processed.add('VERSION')
            outfile.write(' VERSION=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.VERSION), input_name='VERSION')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='creatorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NAME', node)
        if value is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            self.NAME = value
        value = find_attr_value_('VERSION', node)
        if value is not None and 'VERSION' not in already_processed:
            already_processed.add('VERSION')
            self.VERSION = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class creatorType


class createdType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATE=None, TIME=None, valueOf_=None):
        self.original_tagname_ = None
        self.DATE = _cast(None, DATE)
        self.TIME = _cast(None, TIME)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, createdType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if createdType.subclass:
            return createdType.subclass(*args_, **kwargs_)
        else:
            return createdType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATE(self): return self.DATE
    def set_DATE(self, DATE): self.DATE = DATE
    def get_TIME(self): return self.TIME
    def set_TIME(self, TIME): self.TIME = TIME
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='createdType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('createdType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='createdType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='createdType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='createdType'):
        if self.DATE is not None and 'DATE' not in already_processed:
            already_processed.add('DATE')
            outfile.write(' DATE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DATE), input_name='DATE')), ))
        if self.TIME is not None and 'TIME' not in already_processed:
            already_processed.add('TIME')
            outfile.write(' TIME=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TIME), input_name='TIME')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='createdType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DATE', node)
        if value is not None and 'DATE' not in already_processed:
            already_processed.add('DATE')
            self.DATE = value
        value = find_attr_value_('TIME', node)
        if value is not None and 'TIME' not in already_processed:
            already_processed.add('TIME')
            self.TIME = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class createdType


class atomic_speciesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ntyp=None, pseudo_dir=None, species=None):
        self.original_tagname_ = None
        self.ntyp = _cast(int, ntyp)
        self.pseudo_dir = _cast(None, pseudo_dir)
        if species is None:
            self.species = []
        else:
            self.species = species
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, atomic_speciesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if atomic_speciesType.subclass:
            return atomic_speciesType.subclass(*args_, **kwargs_)
        else:
            return atomic_speciesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_species(self): return self.species
    def set_species(self, species): self.species = species
    def add_species(self, value): self.species.append(value)
    def insert_species_at(self, index, value): self.species.insert(index, value)
    def replace_species_at(self, index, value): self.species[index] = value
    def get_ntyp(self): return self.ntyp
    def set_ntyp(self, ntyp): self.ntyp = ntyp
    def get_pseudo_dir(self): return self.pseudo_dir
    def set_pseudo_dir(self, pseudo_dir): self.pseudo_dir = pseudo_dir
    def hasContent_(self):
        if (
            self.species
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='atomic_speciesType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('atomic_speciesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='atomic_speciesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='atomic_speciesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='atomic_speciesType'):
        if self.ntyp is not None and 'ntyp' not in already_processed:
            already_processed.add('ntyp')
            outfile.write(' ntyp="%s"' % self.gds_format_integer(self.ntyp, input_name='ntyp'))
        if self.pseudo_dir is not None and 'pseudo_dir' not in already_processed:
            already_processed.add('pseudo_dir')
            outfile.write(' pseudo_dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pseudo_dir), input_name='pseudo_dir')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='atomic_speciesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for species_ in self.species:
            species_.export(outfile, level, namespaceprefix_, name_='species', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ntyp', node)
        if value is not None and 'ntyp' not in already_processed:
            already_processed.add('ntyp')
            try:
                self.ntyp = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ntyp <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('pseudo_dir', node)
        if value is not None and 'pseudo_dir' not in already_processed:
            already_processed.add('pseudo_dir')
            self.pseudo_dir = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'species':
            obj_ = speciesType.factory()
            obj_.build(child_)
            self.species.append(obj_)
            obj_.original_tagname_ = 'species'
# end class atomic_speciesType


class speciesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, mass=None, pseudo_file=None, starting_magnetization=0.0, spin_teta=None, spin_phi=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.mass = mass
        self.pseudo_file = pseudo_file
        self.starting_magnetization = starting_magnetization
        self.spin_teta = spin_teta
        self.spin_phi = spin_phi
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, speciesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if speciesType.subclass:
            return speciesType.subclass(*args_, **kwargs_)
        else:
            return speciesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mass(self): return self.mass
    def set_mass(self, mass): self.mass = mass
    def get_pseudo_file(self): return self.pseudo_file
    def set_pseudo_file(self, pseudo_file): self.pseudo_file = pseudo_file
    def get_starting_magnetization(self): return self.starting_magnetization
    def set_starting_magnetization(self, starting_magnetization): self.starting_magnetization = starting_magnetization
    def get_spin_teta(self): return self.spin_teta
    def set_spin_teta(self, spin_teta): self.spin_teta = spin_teta
    def get_spin_phi(self): return self.spin_phi
    def set_spin_phi(self, spin_phi): self.spin_phi = spin_phi
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.mass is not None or
            self.pseudo_file is not None or
            self.starting_magnetization != 0.0 or
            self.spin_teta is not None or
            self.spin_phi is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='speciesType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('speciesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='speciesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='speciesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='speciesType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='speciesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:mass>%s</qes:mass>%s' % (self.gds_format_double(self.mass, input_name='mass'), eol_))
        if self.pseudo_file is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:pseudo_file>%s</qes:pseudo_file>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pseudo_file), input_name='pseudo_file')), eol_))
        if self.starting_magnetization != 0.0:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:starting_magnetization>%s</qes:starting_magnetization>%s' % (self.gds_format_double(self.starting_magnetization, input_name='starting_magnetization'), eol_))
        if self.spin_teta is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:spin_teta>%s</qes:spin_teta>%s' % (self.gds_format_double(self.spin_teta, input_name='spin_teta'), eol_))
        if self.spin_phi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:spin_phi>%s</qes:spin_phi>%s' % (self.gds_format_double(self.spin_phi, input_name='spin_phi'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mass' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'mass')
            self.mass = fval_
        elif nodeName_ == 'pseudo_file':
            pseudo_file_ = child_.text
            pseudo_file_ = self.gds_validate_string(pseudo_file_, node, 'pseudo_file')
            self.pseudo_file = pseudo_file_
        elif nodeName_ == 'starting_magnetization' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'starting_magnetization')
            self.starting_magnetization = fval_
        elif nodeName_ == 'spin_teta' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'spin_teta')
            self.spin_teta = fval_
        elif nodeName_ == 'spin_phi' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'spin_phi')
            self.spin_phi = fval_
# end class speciesType


class atomic_structureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nat=None, alat=None, bravais_index=None, atomic_positions=None, wyckoff_positions=None, crystal_positions=None, cell=None):
        self.original_tagname_ = None
        self.nat = _cast(int, nat)
        self.alat = _cast(float, alat)
        self.bravais_index = _cast(int, bravais_index)
        self.atomic_positions = atomic_positions
        self.wyckoff_positions = wyckoff_positions
        self.crystal_positions = crystal_positions
        self.cell = cell
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, atomic_structureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if atomic_structureType.subclass:
            return atomic_structureType.subclass(*args_, **kwargs_)
        else:
            return atomic_structureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_atomic_positions(self): return self.atomic_positions
    def set_atomic_positions(self, atomic_positions): self.atomic_positions = atomic_positions
    def get_wyckoff_positions(self): return self.wyckoff_positions
    def set_wyckoff_positions(self, wyckoff_positions): self.wyckoff_positions = wyckoff_positions
    def get_crystal_positions(self): return self.crystal_positions
    def set_crystal_positions(self, crystal_positions): self.crystal_positions = crystal_positions
    def get_cell(self): return self.cell
    def set_cell(self, cell): self.cell = cell
    def get_nat(self): return self.nat
    def set_nat(self, nat): self.nat = nat
    def get_alat(self): return self.alat
    def set_alat(self, alat): self.alat = alat
    def get_bravais_index(self): return self.bravais_index
    def set_bravais_index(self, bravais_index): self.bravais_index = bravais_index
    def hasContent_(self):
        if (
            self.atomic_positions is not None or
            self.wyckoff_positions is not None or
            self.crystal_positions is not None or
            self.cell is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='atomic_structureType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('atomic_structureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='atomic_structureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='atomic_structureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='atomic_structureType'):
        if self.nat is not None and 'nat' not in already_processed:
            already_processed.add('nat')
            outfile.write(' nat="%s"' % self.gds_format_integer(self.nat, input_name='nat'))
        if self.alat is not None and 'alat' not in already_processed:
            already_processed.add('alat')
            outfile.write(' alat="%s"' % self.gds_format_double(self.alat, input_name='alat'))
        if self.bravais_index is not None and 'bravais_index' not in already_processed:
            already_processed.add('bravais_index')
            outfile.write(' bravais_index="%s"' % self.gds_format_integer(self.bravais_index, input_name='bravais_index'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='atomic_structureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.atomic_positions is not None:
            self.atomic_positions.export(outfile, level, namespaceprefix_, name_='atomic_positions', pretty_print=pretty_print)
        if self.wyckoff_positions is not None:
            self.wyckoff_positions.export(outfile, level, namespaceprefix_, name_='wyckoff_positions', pretty_print=pretty_print)
        if self.crystal_positions is not None:
            self.crystal_positions.export(outfile, level, namespaceprefix_, name_='crystal_positions', pretty_print=pretty_print)
        if self.cell is not None:
            self.cell.export(outfile, level, namespaceprefix_, name_='cell', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nat', node)
        if value is not None and 'nat' not in already_processed:
            already_processed.add('nat')
            try:
                self.nat = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.nat <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('alat', node)
        if value is not None and 'alat' not in already_processed:
            already_processed.add('alat')
            try:
                self.alat = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (alat): %s' % exp)
        value = find_attr_value_('bravais_index', node)
        if value is not None and 'bravais_index' not in already_processed:
            already_processed.add('bravais_index')
            try:
                self.bravais_index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.bravais_index <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'atomic_positions':
            obj_ = atomic_positionsType.factory()
            obj_.build(child_)
            self.atomic_positions = obj_
            obj_.original_tagname_ = 'atomic_positions'
        elif nodeName_ == 'wyckoff_positions':
            obj_ = wyckoff_positionsType.factory()
            obj_.build(child_)
            self.wyckoff_positions = obj_
            obj_.original_tagname_ = 'wyckoff_positions'
        elif nodeName_ == 'crystal_positions':
            obj_ = atomic_positionsType.factory()
            obj_.build(child_)
            self.crystal_positions = obj_
            obj_.original_tagname_ = 'crystal_positions'
        elif nodeName_ == 'cell':
            obj_ = cellType.factory()
            obj_.build(child_)
            self.cell = obj_
            obj_.original_tagname_ = 'cell'
# end class atomic_structureType


class atomic_positionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, atom=None):
        self.original_tagname_ = None
        if atom is None:
            self.atom = []
        else:
            self.atom = atom
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, atomic_positionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if atomic_positionsType.subclass:
            return atomic_positionsType.subclass(*args_, **kwargs_)
        else:
            return atomic_positionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_atom(self): return self.atom
    def set_atom(self, atom): self.atom = atom
    def add_atom(self, value): self.atom.append(value)
    def insert_atom_at(self, index, value): self.atom.insert(index, value)
    def replace_atom_at(self, index, value): self.atom[index] = value
    def hasContent_(self):
        if (
            self.atom
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='atomic_positionsType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('atomic_positionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='atomic_positionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='atomic_positionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='atomic_positionsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='atomic_positionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for atom_ in self.atom:
            atom_.export(outfile, level, namespaceprefix_, name_='atom', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'atom':
            obj_ = atomType.factory()
            obj_.build(child_)
            self.atom.append(obj_)
            obj_.original_tagname_ = 'atom'
# end class atomic_positionsType


class atomType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, position=None, index=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.position = _cast(None, position)
        self.index = _cast(int, index)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, atomType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if atomType.subclass:
            return atomType.subclass(*args_, **kwargs_)
        else:
            return atomType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='atomType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('atomType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='atomType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='atomType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='atomType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.position), input_name='position')), ))
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='atomType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            self.position = value
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            try:
                self.index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.index <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class atomType


class wyckoff_positionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space_group=None, more_options=None, atom=None):
        self.original_tagname_ = None
        self.space_group = _cast(int, space_group)
        self.more_options = _cast(None, more_options)
        if atom is None:
            self.atom = []
        else:
            self.atom = atom
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, wyckoff_positionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if wyckoff_positionsType.subclass:
            return wyckoff_positionsType.subclass(*args_, **kwargs_)
        else:
            return wyckoff_positionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_atom(self): return self.atom
    def set_atom(self, atom): self.atom = atom
    def add_atom(self, value): self.atom.append(value)
    def insert_atom_at(self, index, value): self.atom.insert(index, value)
    def replace_atom_at(self, index, value): self.atom[index] = value
    def get_space_group(self): return self.space_group
    def set_space_group(self, space_group): self.space_group = space_group
    def get_more_options(self): return self.more_options
    def set_more_options(self, more_options): self.more_options = more_options
    def hasContent_(self):
        if (
            self.atom
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='wyckoff_positionsType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('wyckoff_positionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='wyckoff_positionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='wyckoff_positionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='wyckoff_positionsType'):
        if self.space_group is not None and 'space_group' not in already_processed:
            already_processed.add('space_group')
            outfile.write(' space_group="%s"' % self.gds_format_integer(self.space_group, input_name='space_group'))
        if self.more_options is not None and 'more_options' not in already_processed:
            already_processed.add('more_options')
            outfile.write(' more_options=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.more_options), input_name='more_options')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='wyckoff_positionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for atom_ in self.atom:
            atom_.export(outfile, level, namespaceprefix_, name_='atom', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space_group', node)
        if value is not None and 'space_group' not in already_processed:
            already_processed.add('space_group')
            try:
                self.space_group = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('more_options', node)
        if value is not None and 'more_options' not in already_processed:
            already_processed.add('more_options')
            self.more_options = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'atom':
            obj_ = atomType.factory()
            obj_.build(child_)
            self.atom.append(obj_)
            obj_.original_tagname_ = 'atom'
# end class wyckoff_positionsType


class cellType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, a1=None, a2=None, a3=None):
        self.original_tagname_ = None
        self.a1 = a1
        self.validate_d3vectorType(self.a1)
        self.a2 = a2
        self.validate_d3vectorType(self.a2)
        self.a3 = a3
        self.validate_d3vectorType(self.a3)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cellType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cellType.subclass:
            return cellType.subclass(*args_, **kwargs_)
        else:
            return cellType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_a1(self): return self.a1
    def set_a1(self, a1): self.a1 = a1
    def get_a2(self): return self.a2
    def set_a2(self, a2): self.a2 = a2
    def get_a3(self): return self.a3
    def set_a3(self, a3): self.a3 = a3
    def validate_d3vectorType(self, value):
        # Validate type d3vectorType, a restriction on double.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on d3vectorType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.a1 is not None or
            self.a2 is not None or
            self.a3 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='cellType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cellType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cellType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='cellType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='cellType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='cellType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.a1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:a1>%s</qes:a1>%s' % (self.gds_format_double_list(self.a1, input_name='a1'), eol_))
        if self.a2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:a2>%s</qes:a2>%s' % (self.gds_format_double_list(self.a2, input_name='a2'), eol_))
        if self.a3 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:a3>%s</qes:a3>%s' % (self.gds_format_double_list(self.a3, input_name='a3'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'a1':
            a1_ = child_.text
            a1_ = self.gds_validate_double_list(a1_, node, 'a1')
            self.a1 = a1_
            # validate type d3vectorType
            self.validate_d3vectorType(self.a1)
        elif nodeName_ == 'a2':
            a2_ = child_.text
            a2_ = self.gds_validate_double_list(a2_, node, 'a2')
            self.a2 = a2_
            # validate type d3vectorType
            self.validate_d3vectorType(self.a2)
        elif nodeName_ == 'a3':
            a3_ = child_.text
            a3_ = self.gds_validate_double_list(a3_, node, 'a3')
            self.a3 = a3_
            # validate type d3vectorType
            self.validate_d3vectorType(self.a3)
# end class cellType


class dftType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, functional=None, hybrid=None, dftU=None, vdW=None):
        self.original_tagname_ = None
        self.functional = functional
        self.validate_functionalType(self.functional)
        self.hybrid = hybrid
        self.dftU = dftU
        self.vdW = vdW
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dftType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dftType.subclass:
            return dftType.subclass(*args_, **kwargs_)
        else:
            return dftType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_functional(self): return self.functional
    def set_functional(self, functional): self.functional = functional
    def get_hybrid(self): return self.hybrid
    def set_hybrid(self, hybrid): self.hybrid = hybrid
    def get_dftU(self): return self.dftU
    def set_dftU(self, dftU): self.dftU = dftU
    def get_vdW(self): return self.vdW
    def set_vdW(self, vdW): self.vdW = vdW
    def validate_functionalType(self, value):
        # Validate type functionalType, a restriction on string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PZ', 'BP', 'PBE', 'REVPBE', 'PBESOL', 'BLYP', 'OLYP', 'PW91', 'WC', 'SOGGA', 'EV93', 'B3LYP', 'GauPBE', 'PBE0', 'HSE', 'VDW-DF', 'VDW-DF-CX', 'VDW-DF-C09', 'VDW-DF-OB86', 'VDW-DF-OBK8', 'VDW-DF2', 'VDW-DF2-C09', 'VDW-DF2-B86R', 'RVV10']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on functionalType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.functional is not None or
            self.hybrid is not None or
            self.dftU is not None or
            self.vdW is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='dftType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dftType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dftType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='dftType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='dftType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='dftType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.functional is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:functional>%s</qes:functional>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.functional), input_name='functional')), eol_))
        if self.hybrid is not None:
            self.hybrid.export(outfile, level, namespaceprefix_, name_='hybrid', pretty_print=pretty_print)
        if self.dftU is not None:
            self.dftU.export(outfile, level, namespaceprefix_, name_='dftU', pretty_print=pretty_print)
        if self.vdW is not None:
            self.vdW.export(outfile, level, namespaceprefix_, name_='vdW', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'functional':
            functional_ = child_.text
            functional_ = self.gds_validate_string(functional_, node, 'functional')
            self.functional = functional_
            # validate type functionalType
            self.validate_functionalType(self.functional)
        elif nodeName_ == 'hybrid':
            obj_ = hybridType.factory()
            obj_.build(child_)
            self.hybrid = obj_
            obj_.original_tagname_ = 'hybrid'
        elif nodeName_ == 'dftU':
            obj_ = dftUType.factory()
            obj_.build(child_)
            self.dftU = obj_
            obj_.original_tagname_ = 'dftU'
        elif nodeName_ == 'vdW':
            obj_ = vdWType.factory()
            obj_.build(child_)
            self.vdW = obj_
            obj_.original_tagname_ = 'vdW'
# end class dftType


class hybridType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, qpoint_grid=None, ecutfock=None, exx_fraction=None, screening_parameter=None, exxdiv_treatment=None, x_gamma_extrapolation=None, ecutvcut=None):
        self.original_tagname_ = None
        self.qpoint_grid = qpoint_grid
        self.ecutfock = ecutfock
        self.exx_fraction = exx_fraction
        self.screening_parameter = screening_parameter
        self.exxdiv_treatment = exxdiv_treatment
        self.x_gamma_extrapolation = x_gamma_extrapolation
        self.ecutvcut = ecutvcut
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hybridType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hybridType.subclass:
            return hybridType.subclass(*args_, **kwargs_)
        else:
            return hybridType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qpoint_grid(self): return self.qpoint_grid
    def set_qpoint_grid(self, qpoint_grid): self.qpoint_grid = qpoint_grid
    def get_ecutfock(self): return self.ecutfock
    def set_ecutfock(self, ecutfock): self.ecutfock = ecutfock
    def get_exx_fraction(self): return self.exx_fraction
    def set_exx_fraction(self, exx_fraction): self.exx_fraction = exx_fraction
    def get_screening_parameter(self): return self.screening_parameter
    def set_screening_parameter(self, screening_parameter): self.screening_parameter = screening_parameter
    def get_exxdiv_treatment(self): return self.exxdiv_treatment
    def set_exxdiv_treatment(self, exxdiv_treatment): self.exxdiv_treatment = exxdiv_treatment
    def get_x_gamma_extrapolation(self): return self.x_gamma_extrapolation
    def set_x_gamma_extrapolation(self, x_gamma_extrapolation): self.x_gamma_extrapolation = x_gamma_extrapolation
    def get_ecutvcut(self): return self.ecutvcut
    def set_ecutvcut(self, ecutvcut): self.ecutvcut = ecutvcut
    def hasContent_(self):
        if (
            self.qpoint_grid is not None or
            self.ecutfock is not None or
            self.exx_fraction is not None or
            self.screening_parameter is not None or
            self.exxdiv_treatment is not None or
            self.x_gamma_extrapolation is not None or
            self.ecutvcut is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='hybridType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hybridType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hybridType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='hybridType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='hybridType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='hybridType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qpoint_grid is not None:
            self.qpoint_grid.export(outfile, level, namespaceprefix_, name_='qpoint_grid', pretty_print=pretty_print)
        if self.ecutfock is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ecutfock>%s</qes:ecutfock>%s' % (self.gds_format_double(self.ecutfock, input_name='ecutfock'), eol_))
        if self.exx_fraction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:exx_fraction>%s</qes:exx_fraction>%s' % (self.gds_format_double(self.exx_fraction, input_name='exx_fraction'), eol_))
        if self.screening_parameter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:screening_parameter>%s</qes:screening_parameter>%s' % (self.gds_format_double(self.screening_parameter, input_name='screening_parameter'), eol_))
        if self.exxdiv_treatment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:exxdiv_treatment>%s</qes:exxdiv_treatment>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.exxdiv_treatment), input_name='exxdiv_treatment')), eol_))
        if self.x_gamma_extrapolation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:x_gamma_extrapolation>%s</qes:x_gamma_extrapolation>%s' % (self.gds_format_boolean(self.x_gamma_extrapolation, input_name='x_gamma_extrapolation'), eol_))
        if self.ecutvcut is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ecutvcut>%s</qes:ecutvcut>%s' % (self.gds_format_double(self.ecutvcut, input_name='ecutvcut'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qpoint_grid':
            obj_ = qpoint_gridType.factory()
            obj_.build(child_)
            self.qpoint_grid = obj_
            obj_.original_tagname_ = 'qpoint_grid'
        elif nodeName_ == 'ecutfock' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ecutfock')
            self.ecutfock = fval_
        elif nodeName_ == 'exx_fraction' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'exx_fraction')
            self.exx_fraction = fval_
        elif nodeName_ == 'screening_parameter' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'screening_parameter')
            self.screening_parameter = fval_
        elif nodeName_ == 'exxdiv_treatment':
            exxdiv_treatment_ = child_.text
            exxdiv_treatment_ = self.gds_validate_string(exxdiv_treatment_, node, 'exxdiv_treatment')
            self.exxdiv_treatment = exxdiv_treatment_
        elif nodeName_ == 'x_gamma_extrapolation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'x_gamma_extrapolation')
            self.x_gamma_extrapolation = ival_
        elif nodeName_ == 'ecutvcut' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ecutvcut')
            self.ecutvcut = fval_
# end class hybridType


class qpoint_gridType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nqx1=None, nqx2=None, nqx3=None, valueOf_=None):
        self.original_tagname_ = None
        self.nqx1 = _cast(int, nqx1)
        self.nqx2 = _cast(int, nqx2)
        self.nqx3 = _cast(int, nqx3)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qpoint_gridType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qpoint_gridType.subclass:
            return qpoint_gridType.subclass(*args_, **kwargs_)
        else:
            return qpoint_gridType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nqx1(self): return self.nqx1
    def set_nqx1(self, nqx1): self.nqx1 = nqx1
    def get_nqx2(self): return self.nqx2
    def set_nqx2(self, nqx2): self.nqx2 = nqx2
    def get_nqx3(self): return self.nqx3
    def set_nqx3(self, nqx3): self.nqx3 = nqx3
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='qpoint_gridType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qpoint_gridType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='qpoint_gridType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='qpoint_gridType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='qpoint_gridType'):
        if self.nqx1 is not None and 'nqx1' not in already_processed:
            already_processed.add('nqx1')
            outfile.write(' nqx1="%s"' % self.gds_format_integer(self.nqx1, input_name='nqx1'))
        if self.nqx2 is not None and 'nqx2' not in already_processed:
            already_processed.add('nqx2')
            outfile.write(' nqx2="%s"' % self.gds_format_integer(self.nqx2, input_name='nqx2'))
        if self.nqx3 is not None and 'nqx3' not in already_processed:
            already_processed.add('nqx3')
            outfile.write(' nqx3="%s"' % self.gds_format_integer(self.nqx3, input_name='nqx3'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='qpoint_gridType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nqx1', node)
        if value is not None and 'nqx1' not in already_processed:
            already_processed.add('nqx1')
            try:
                self.nqx1 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.nqx1 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('nqx2', node)
        if value is not None and 'nqx2' not in already_processed:
            already_processed.add('nqx2')
            try:
                self.nqx2 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.nqx2 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('nqx3', node)
        if value is not None and 'nqx3' not in already_processed:
            already_processed.add('nqx3')
            try:
                self.nqx3 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.nqx3 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qpoint_gridType


class dftUType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lda_plus_u_kind=None, Hubbard_U=None, Hubbard_J0=None, Hubbard_alpha=None, Hubbard_beta=None, Hubbard_J=None, starting_ns=None, Hubbard_ns=None, U_projection_type=None):
        self.original_tagname_ = None
        self.lda_plus_u_kind = lda_plus_u_kind
        if Hubbard_U is None:
            self.Hubbard_U = []
        else:
            self.Hubbard_U = Hubbard_U
        if Hubbard_J0 is None:
            self.Hubbard_J0 = []
        else:
            self.Hubbard_J0 = Hubbard_J0
        if Hubbard_alpha is None:
            self.Hubbard_alpha = []
        else:
            self.Hubbard_alpha = Hubbard_alpha
        if Hubbard_beta is None:
            self.Hubbard_beta = []
        else:
            self.Hubbard_beta = Hubbard_beta
        if Hubbard_J is None:
            self.Hubbard_J = []
        else:
            self.Hubbard_J = Hubbard_J
        if starting_ns is None:
            self.starting_ns = []
        else:
            self.starting_ns = starting_ns
        if Hubbard_ns is None:
            self.Hubbard_ns = []
        else:
            self.Hubbard_ns = Hubbard_ns
        self.U_projection_type = U_projection_type
        self.validate_HubbardProjType(self.U_projection_type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dftUType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dftUType.subclass:
            return dftUType.subclass(*args_, **kwargs_)
        else:
            return dftUType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lda_plus_u_kind(self): return self.lda_plus_u_kind
    def set_lda_plus_u_kind(self, lda_plus_u_kind): self.lda_plus_u_kind = lda_plus_u_kind
    def get_Hubbard_U(self): return self.Hubbard_U
    def set_Hubbard_U(self, Hubbard_U): self.Hubbard_U = Hubbard_U
    def add_Hubbard_U(self, value): self.Hubbard_U.append(value)
    def insert_Hubbard_U_at(self, index, value): self.Hubbard_U.insert(index, value)
    def replace_Hubbard_U_at(self, index, value): self.Hubbard_U[index] = value
    def get_Hubbard_J0(self): return self.Hubbard_J0
    def set_Hubbard_J0(self, Hubbard_J0): self.Hubbard_J0 = Hubbard_J0
    def add_Hubbard_J0(self, value): self.Hubbard_J0.append(value)
    def insert_Hubbard_J0_at(self, index, value): self.Hubbard_J0.insert(index, value)
    def replace_Hubbard_J0_at(self, index, value): self.Hubbard_J0[index] = value
    def get_Hubbard_alpha(self): return self.Hubbard_alpha
    def set_Hubbard_alpha(self, Hubbard_alpha): self.Hubbard_alpha = Hubbard_alpha
    def add_Hubbard_alpha(self, value): self.Hubbard_alpha.append(value)
    def insert_Hubbard_alpha_at(self, index, value): self.Hubbard_alpha.insert(index, value)
    def replace_Hubbard_alpha_at(self, index, value): self.Hubbard_alpha[index] = value
    def get_Hubbard_beta(self): return self.Hubbard_beta
    def set_Hubbard_beta(self, Hubbard_beta): self.Hubbard_beta = Hubbard_beta
    def add_Hubbard_beta(self, value): self.Hubbard_beta.append(value)
    def insert_Hubbard_beta_at(self, index, value): self.Hubbard_beta.insert(index, value)
    def replace_Hubbard_beta_at(self, index, value): self.Hubbard_beta[index] = value
    def get_Hubbard_J(self): return self.Hubbard_J
    def set_Hubbard_J(self, Hubbard_J): self.Hubbard_J = Hubbard_J
    def add_Hubbard_J(self, value): self.Hubbard_J.append(value)
    def insert_Hubbard_J_at(self, index, value): self.Hubbard_J.insert(index, value)
    def replace_Hubbard_J_at(self, index, value): self.Hubbard_J[index] = value
    def get_starting_ns(self): return self.starting_ns
    def set_starting_ns(self, starting_ns): self.starting_ns = starting_ns
    def add_starting_ns(self, value): self.starting_ns.append(value)
    def insert_starting_ns_at(self, index, value): self.starting_ns.insert(index, value)
    def replace_starting_ns_at(self, index, value): self.starting_ns[index] = value
    def get_Hubbard_ns(self): return self.Hubbard_ns
    def set_Hubbard_ns(self, Hubbard_ns): self.Hubbard_ns = Hubbard_ns
    def add_Hubbard_ns(self, value): self.Hubbard_ns.append(value)
    def insert_Hubbard_ns_at(self, index, value): self.Hubbard_ns.insert(index, value)
    def replace_Hubbard_ns_at(self, index, value): self.Hubbard_ns[index] = value
    def get_U_projection_type(self): return self.U_projection_type
    def set_U_projection_type(self, U_projection_type): self.U_projection_type = U_projection_type
    def validate_HubbardProjType(self, value):
        # Validate type HubbardProjType, a restriction on string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['atomic', 'ortho-atomic', 'norm-atomic', 'pseudo', 'file']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HubbardProjType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.lda_plus_u_kind is not None or
            self.Hubbard_U or
            self.Hubbard_J0 or
            self.Hubbard_alpha or
            self.Hubbard_beta or
            self.Hubbard_J or
            self.starting_ns or
            self.Hubbard_ns or
            self.U_projection_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='dftUType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dftUType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dftUType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='dftUType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='dftUType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='dftUType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lda_plus_u_kind is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:lda_plus_u_kind>%s</qes:lda_plus_u_kind>%s' % (self.gds_format_integer(self.lda_plus_u_kind, input_name='lda_plus_u_kind'), eol_))
        for Hubbard_U_ in self.Hubbard_U:
            Hubbard_U_.export(outfile, level, namespaceprefix_, name_='Hubbard_U', pretty_print=pretty_print)
        for Hubbard_J0_ in self.Hubbard_J0:
            Hubbard_J0_.export(outfile, level, namespaceprefix_, name_='Hubbard_J0', pretty_print=pretty_print)
        for Hubbard_alpha_ in self.Hubbard_alpha:
            Hubbard_alpha_.export(outfile, level, namespaceprefix_, name_='Hubbard_alpha', pretty_print=pretty_print)
        for Hubbard_beta_ in self.Hubbard_beta:
            Hubbard_beta_.export(outfile, level, namespaceprefix_, name_='Hubbard_beta', pretty_print=pretty_print)
        for Hubbard_J_ in self.Hubbard_J:
            Hubbard_J_.export(outfile, level, namespaceprefix_, name_='Hubbard_J', pretty_print=pretty_print)
        for starting_ns_ in self.starting_ns:
            starting_ns_.export(outfile, level, namespaceprefix_, name_='starting_ns', pretty_print=pretty_print)
        for Hubbard_ns_ in self.Hubbard_ns:
            Hubbard_ns_.export(outfile, level, namespaceprefix_, name_='Hubbard_ns', pretty_print=pretty_print)
        if self.U_projection_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:U_projection_type>%s</qes:U_projection_type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.U_projection_type), input_name='U_projection_type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lda_plus_u_kind' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lda_plus_u_kind')
            self.lda_plus_u_kind = ival_
        elif nodeName_ == 'Hubbard_U':
            obj_ = HubbardCommonType.factory()
            obj_.build(child_)
            self.Hubbard_U.append(obj_)
            obj_.original_tagname_ = 'Hubbard_U'
        elif nodeName_ == 'Hubbard_J0':
            obj_ = HubbardCommonType.factory()
            obj_.build(child_)
            self.Hubbard_J0.append(obj_)
            obj_.original_tagname_ = 'Hubbard_J0'
        elif nodeName_ == 'Hubbard_alpha':
            obj_ = HubbardCommonType.factory()
            obj_.build(child_)
            self.Hubbard_alpha.append(obj_)
            obj_.original_tagname_ = 'Hubbard_alpha'
        elif nodeName_ == 'Hubbard_beta':
            obj_ = HubbardCommonType.factory()
            obj_.build(child_)
            self.Hubbard_beta.append(obj_)
            obj_.original_tagname_ = 'Hubbard_beta'
        elif nodeName_ == 'Hubbard_J':
            obj_ = HubbardJType.factory()
            obj_.build(child_)
            self.Hubbard_J.append(obj_)
            obj_.original_tagname_ = 'Hubbard_J'
        elif nodeName_ == 'starting_ns':
            obj_ = starting_nsType.factory()
            obj_.build(child_)
            self.starting_ns.append(obj_)
            obj_.original_tagname_ = 'starting_ns'
        elif nodeName_ == 'Hubbard_ns':
            obj_ = Hubbard_nsType.factory()
            obj_.build(child_)
            self.Hubbard_ns.append(obj_)
            obj_.original_tagname_ = 'Hubbard_ns'
        elif nodeName_ == 'U_projection_type':
            U_projection_type_ = child_.text
            U_projection_type_ = self.gds_validate_string(U_projection_type_, node, 'U_projection_type')
            self.U_projection_type = U_projection_type_
            # validate type HubbardProjType
            self.validate_HubbardProjType(self.U_projection_type)
# end class dftUType


class HubbardCommonType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, specie=None, label=None, valueOf_=None):
        self.original_tagname_ = None
        self.specie = _cast(None, specie)
        self.label = _cast(None, label)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HubbardCommonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HubbardCommonType.subclass:
            return HubbardCommonType.subclass(*args_, **kwargs_)
        else:
            return HubbardCommonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_specie(self): return self.specie
    def set_specie(self, specie): self.specie = specie
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='HubbardCommonType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HubbardCommonType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HubbardCommonType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='HubbardCommonType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='HubbardCommonType'):
        if self.specie is not None and 'specie' not in already_processed:
            already_processed.add('specie')
            outfile.write(' specie=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.specie), input_name='specie')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='HubbardCommonType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('specie', node)
        if value is not None and 'specie' not in already_processed:
            already_processed.add('specie')
            self.specie = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HubbardCommonType


class HubbardJType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, specie=None, label=None, valueOf_=None):
        self.original_tagname_ = None
        self.specie = _cast(None, specie)
        self.label = _cast(None, label)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HubbardJType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HubbardJType.subclass:
            return HubbardJType.subclass(*args_, **kwargs_)
        else:
            return HubbardJType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_specie(self): return self.specie
    def set_specie(self, specie): self.specie = specie
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='HubbardJType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HubbardJType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HubbardJType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='HubbardJType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='HubbardJType'):
        if self.specie is not None and 'specie' not in already_processed:
            already_processed.add('specie')
            outfile.write(' specie=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.specie), input_name='specie')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='HubbardJType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('specie', node)
        if value is not None and 'specie' not in already_processed:
            already_processed.add('specie')
            self.specie = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HubbardJType


class vdWType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vdw_corr=None, non_local_term=None, london_s6=None, ts_vdw_econv_thr=None, ts_vdw_isolated=None, london_rcut=None, xdm_a1=None, xdm_a2=None, london_c6=None):
        self.original_tagname_ = None
        self.vdw_corr = vdw_corr
        self.non_local_term = non_local_term
        self.london_s6 = london_s6
        self.ts_vdw_econv_thr = ts_vdw_econv_thr
        self.ts_vdw_isolated = ts_vdw_isolated
        self.london_rcut = london_rcut
        self.xdm_a1 = xdm_a1
        self.xdm_a2 = xdm_a2
        if london_c6 is None:
            self.london_c6 = []
        else:
            self.london_c6 = london_c6
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vdWType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vdWType.subclass:
            return vdWType.subclass(*args_, **kwargs_)
        else:
            return vdWType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vdw_corr(self): return self.vdw_corr
    def set_vdw_corr(self, vdw_corr): self.vdw_corr = vdw_corr
    def get_non_local_term(self): return self.non_local_term
    def set_non_local_term(self, non_local_term): self.non_local_term = non_local_term
    def get_london_s6(self): return self.london_s6
    def set_london_s6(self, london_s6): self.london_s6 = london_s6
    def get_ts_vdw_econv_thr(self): return self.ts_vdw_econv_thr
    def set_ts_vdw_econv_thr(self, ts_vdw_econv_thr): self.ts_vdw_econv_thr = ts_vdw_econv_thr
    def get_ts_vdw_isolated(self): return self.ts_vdw_isolated
    def set_ts_vdw_isolated(self, ts_vdw_isolated): self.ts_vdw_isolated = ts_vdw_isolated
    def get_london_rcut(self): return self.london_rcut
    def set_london_rcut(self, london_rcut): self.london_rcut = london_rcut
    def get_xdm_a1(self): return self.xdm_a1
    def set_xdm_a1(self, xdm_a1): self.xdm_a1 = xdm_a1
    def get_xdm_a2(self): return self.xdm_a2
    def set_xdm_a2(self, xdm_a2): self.xdm_a2 = xdm_a2
    def get_london_c6(self): return self.london_c6
    def set_london_c6(self, london_c6): self.london_c6 = london_c6
    def add_london_c6(self, value): self.london_c6.append(value)
    def insert_london_c6_at(self, index, value): self.london_c6.insert(index, value)
    def replace_london_c6_at(self, index, value): self.london_c6[index] = value
    def hasContent_(self):
        if (
            self.vdw_corr is not None or
            self.non_local_term is not None or
            self.london_s6 is not None or
            self.ts_vdw_econv_thr is not None or
            self.ts_vdw_isolated is not None or
            self.london_rcut is not None or
            self.xdm_a1 is not None or
            self.xdm_a2 is not None or
            self.london_c6
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='vdWType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vdWType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vdWType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='vdWType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='vdWType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='vdWType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vdw_corr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:vdw_corr>%s</qes:vdw_corr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vdw_corr), input_name='vdw_corr')), eol_))
        if self.non_local_term is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:non_local_term>%s</qes:non_local_term>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.non_local_term), input_name='non_local_term')), eol_))
        if self.london_s6 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:london_s6>%s</qes:london_s6>%s' % (self.gds_format_double(self.london_s6, input_name='london_s6'), eol_))
        if self.ts_vdw_econv_thr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ts_vdw_econv_thr>%s</qes:ts_vdw_econv_thr>%s' % (self.gds_format_double(self.ts_vdw_econv_thr, input_name='ts_vdw_econv_thr'), eol_))
        if self.ts_vdw_isolated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ts_vdw_isolated>%s</qes:ts_vdw_isolated>%s' % (self.gds_format_boolean(self.ts_vdw_isolated, input_name='ts_vdw_isolated'), eol_))
        if self.london_rcut is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:london_rcut>%s</qes:london_rcut>%s' % (self.gds_format_double(self.london_rcut, input_name='london_rcut'), eol_))
        if self.xdm_a1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:xdm_a1>%s</qes:xdm_a1>%s' % (self.gds_format_double(self.xdm_a1, input_name='xdm_a1'), eol_))
        if self.xdm_a2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:xdm_a2>%s</qes:xdm_a2>%s' % (self.gds_format_double(self.xdm_a2, input_name='xdm_a2'), eol_))
        for london_c6_ in self.london_c6:
            london_c6_.export(outfile, level, namespaceprefix_, name_='london_c6', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vdw_corr':
            vdw_corr_ = child_.text
            vdw_corr_ = self.gds_validate_string(vdw_corr_, node, 'vdw_corr')
            self.vdw_corr = vdw_corr_
        elif nodeName_ == 'non_local_term':
            non_local_term_ = child_.text
            non_local_term_ = self.gds_validate_string(non_local_term_, node, 'non_local_term')
            self.non_local_term = non_local_term_
        elif nodeName_ == 'london_s6' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'london_s6')
            self.london_s6 = fval_
        elif nodeName_ == 'ts_vdw_econv_thr' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ts_vdw_econv_thr')
            self.ts_vdw_econv_thr = fval_
        elif nodeName_ == 'ts_vdw_isolated':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ts_vdw_isolated')
            self.ts_vdw_isolated = ival_
        elif nodeName_ == 'london_rcut' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'london_rcut')
            self.london_rcut = fval_
        elif nodeName_ == 'xdm_a1' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'xdm_a1')
            self.xdm_a1 = fval_
        elif nodeName_ == 'xdm_a2' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'xdm_a2')
            self.xdm_a2 = fval_
        elif nodeName_ == 'london_c6':
            obj_ = HubbardCommonType.factory()
            obj_.build(child_)
            self.london_c6.append(obj_)
            obj_.original_tagname_ = 'london_c6'
# end class vdWType


class spinType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lsda=None, noncolin=None, spinorbit=None):
        self.original_tagname_ = None
        self.lsda = lsda
        self.noncolin = noncolin
        self.spinorbit = spinorbit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, spinType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if spinType.subclass:
            return spinType.subclass(*args_, **kwargs_)
        else:
            return spinType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lsda(self): return self.lsda
    def set_lsda(self, lsda): self.lsda = lsda
    def get_noncolin(self): return self.noncolin
    def set_noncolin(self, noncolin): self.noncolin = noncolin
    def get_spinorbit(self): return self.spinorbit
    def set_spinorbit(self, spinorbit): self.spinorbit = spinorbit
    def hasContent_(self):
        if (
            self.lsda is not None or
            self.noncolin is not None or
            self.spinorbit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='spinType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('spinType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='spinType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='spinType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='spinType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='spinType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lsda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:lsda>%s</qes:lsda>%s' % (self.gds_format_boolean(self.lsda, input_name='lsda'), eol_))
        if self.noncolin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:noncolin>%s</qes:noncolin>%s' % (self.gds_format_boolean(self.noncolin, input_name='noncolin'), eol_))
        if self.spinorbit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:spinorbit>%s</qes:spinorbit>%s' % (self.gds_format_boolean(self.spinorbit, input_name='spinorbit'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lsda':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'lsda')
            self.lsda = ival_
        elif nodeName_ == 'noncolin':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'noncolin')
            self.noncolin = ival_
        elif nodeName_ == 'spinorbit':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'spinorbit')
            self.spinorbit = ival_
# end class spinType


class bandsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nbnd=None, smearing=None, tot_charge=None, tot_magnetization=None, occupations=None, inputOccupations=None):
        self.original_tagname_ = None
        self.nbnd = nbnd
        self.smearing = smearing
        self.tot_charge = tot_charge
        self.tot_magnetization = tot_magnetization
        self.occupations = occupations
        if inputOccupations is None:
            self.inputOccupations = []
        else:
            self.inputOccupations = inputOccupations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bandsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bandsType.subclass:
            return bandsType.subclass(*args_, **kwargs_)
        else:
            return bandsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nbnd(self): return self.nbnd
    def set_nbnd(self, nbnd): self.nbnd = nbnd
    def get_smearing(self): return self.smearing
    def set_smearing(self, smearing): self.smearing = smearing
    def get_tot_charge(self): return self.tot_charge
    def set_tot_charge(self, tot_charge): self.tot_charge = tot_charge
    def get_tot_magnetization(self): return self.tot_magnetization
    def set_tot_magnetization(self, tot_magnetization): self.tot_magnetization = tot_magnetization
    def get_occupations(self): return self.occupations
    def set_occupations(self, occupations): self.occupations = occupations
    def get_inputOccupations(self): return self.inputOccupations
    def set_inputOccupations(self, inputOccupations): self.inputOccupations = inputOccupations
    def add_inputOccupations(self, value): self.inputOccupations.append(value)
    def insert_inputOccupations_at(self, index, value): self.inputOccupations.insert(index, value)
    def replace_inputOccupations_at(self, index, value): self.inputOccupations[index] = value
    def hasContent_(self):
        if (
            self.nbnd is not None or
            self.smearing is not None or
            self.tot_charge is not None or
            self.tot_magnetization is not None or
            self.occupations is not None or
            self.inputOccupations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='bandsType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bandsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bandsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='bandsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='bandsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='bandsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nbnd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nbnd>%s</qes:nbnd>%s' % (self.gds_format_integer(self.nbnd, input_name='nbnd'), eol_))
        if self.smearing is not None:
            self.smearing.export(outfile, level, namespaceprefix_, name_='smearing', pretty_print=pretty_print)
        if self.tot_charge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:tot_charge>%s</qes:tot_charge>%s' % (self.gds_format_double(self.tot_charge, input_name='tot_charge'), eol_))
        if self.tot_magnetization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:tot_magnetization>%s</qes:tot_magnetization>%s' % (self.gds_format_double(self.tot_magnetization, input_name='tot_magnetization'), eol_))
        if self.occupations is not None:
            self.occupations.export(outfile, level, namespaceprefix_, name_='occupations', pretty_print=pretty_print)
        for inputOccupations_ in self.inputOccupations:
            inputOccupations_.export(outfile, level, namespaceprefix_, name_='inputOccupations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nbnd' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nbnd')
            self.nbnd = ival_
        elif nodeName_ == 'smearing':
            obj_ = smearingType.factory()
            obj_.build(child_)
            self.smearing = obj_
            obj_.original_tagname_ = 'smearing'
        elif nodeName_ == 'tot_charge' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'tot_charge')
            self.tot_charge = fval_
        elif nodeName_ == 'tot_magnetization' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'tot_magnetization')
            self.tot_magnetization = fval_
        elif nodeName_ == 'occupations':
            obj_ = occupationsType.factory()
            obj_.build(child_)
            self.occupations = obj_
            obj_.original_tagname_ = 'occupations'
        elif nodeName_ == 'inputOccupations':
            obj_ = inputOccupationsType.factory()
            obj_.build(child_)
            self.inputOccupations.append(obj_)
            obj_.original_tagname_ = 'inputOccupations'
# end class bandsType


class smearingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, degauss=None, valueOf_=None):
        self.original_tagname_ = None
        self.degauss = _cast(float, degauss)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, smearingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if smearingType.subclass:
            return smearingType.subclass(*args_, **kwargs_)
        else:
            return smearingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_degauss(self): return self.degauss
    def set_degauss(self, degauss): self.degauss = degauss
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='smearingType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('smearingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='smearingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='smearingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='smearingType'):
        if self.degauss is not None and 'degauss' not in already_processed:
            already_processed.add('degauss')
            outfile.write(' degauss="%s"' % self.gds_format_double(self.degauss, input_name='degauss'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='smearingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('degauss', node)
        if value is not None and 'degauss' not in already_processed:
            already_processed.add('degauss')
            try:
                self.degauss = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (degauss): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class smearingType


class occupationsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, spin=None, valueOf_=None):
        self.original_tagname_ = None
        self.spin = _cast(int, spin)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, occupationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if occupationsType.subclass:
            return occupationsType.subclass(*args_, **kwargs_)
        else:
            return occupationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spin(self): return self.spin
    def set_spin(self, spin): self.spin = spin
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='occupationsType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('occupationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='occupationsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='occupationsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='occupationsType'):
        if self.spin is not None and 'spin' not in already_processed:
            already_processed.add('spin')
            outfile.write(' spin="%s"' % self.gds_format_integer(self.spin, input_name='spin'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='occupationsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spin', node)
        if value is not None and 'spin' not in already_processed:
            already_processed.add('spin')
            try:
                self.spin = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.spin <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class occupationsType


class basisType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gamma_only=None, ecutwfc=None, ecutrho=None, fft_grid=None, fft_smooth=None, fft_box=None):
        self.original_tagname_ = None
        self.gamma_only = gamma_only
        self.ecutwfc = ecutwfc
        self.ecutrho = ecutrho
        self.fft_grid = fft_grid
        self.fft_smooth = fft_smooth
        self.fft_box = fft_box
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basisType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basisType.subclass:
            return basisType.subclass(*args_, **kwargs_)
        else:
            return basisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gamma_only(self): return self.gamma_only
    def set_gamma_only(self, gamma_only): self.gamma_only = gamma_only
    def get_ecutwfc(self): return self.ecutwfc
    def set_ecutwfc(self, ecutwfc): self.ecutwfc = ecutwfc
    def get_ecutrho(self): return self.ecutrho
    def set_ecutrho(self, ecutrho): self.ecutrho = ecutrho
    def get_fft_grid(self): return self.fft_grid
    def set_fft_grid(self, fft_grid): self.fft_grid = fft_grid
    def get_fft_smooth(self): return self.fft_smooth
    def set_fft_smooth(self, fft_smooth): self.fft_smooth = fft_smooth
    def get_fft_box(self): return self.fft_box
    def set_fft_box(self, fft_box): self.fft_box = fft_box
    def hasContent_(self):
        if (
            self.gamma_only is not None or
            self.ecutwfc is not None or
            self.ecutrho is not None or
            self.fft_grid is not None or
            self.fft_smooth is not None or
            self.fft_box is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='basisType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basisType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basisType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='basisType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='basisType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='basisType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.gamma_only is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:gamma_only>%s</qes:gamma_only>%s' % (self.gds_format_boolean(self.gamma_only, input_name='gamma_only'), eol_))
        if self.ecutwfc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ecutwfc>%s</qes:ecutwfc>%s' % (self.gds_format_double(self.ecutwfc, input_name='ecutwfc'), eol_))
        if self.ecutrho is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ecutrho>%s</qes:ecutrho>%s' % (self.gds_format_double(self.ecutrho, input_name='ecutrho'), eol_))
        if self.fft_grid is not None:
            self.fft_grid.export(outfile, level, namespaceprefix_, name_='fft_grid', pretty_print=pretty_print)
        if self.fft_smooth is not None:
            self.fft_smooth.export(outfile, level, namespaceprefix_, name_='fft_smooth', pretty_print=pretty_print)
        if self.fft_box is not None:
            self.fft_box.export(outfile, level, namespaceprefix_, name_='fft_box', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gamma_only':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'gamma_only')
            self.gamma_only = ival_
        elif nodeName_ == 'ecutwfc' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ecutwfc')
            self.ecutwfc = fval_
        elif nodeName_ == 'ecutrho' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ecutrho')
            self.ecutrho = fval_
        elif nodeName_ == 'fft_grid':
            obj_ = basisSetItemType.factory()
            obj_.build(child_)
            self.fft_grid = obj_
            obj_.original_tagname_ = 'fft_grid'
        elif nodeName_ == 'fft_smooth':
            obj_ = basisSetItemType.factory()
            obj_.build(child_)
            self.fft_smooth = obj_
            obj_.original_tagname_ = 'fft_smooth'
        elif nodeName_ == 'fft_box':
            obj_ = basisSetItemType.factory()
            obj_.build(child_)
            self.fft_box = obj_
            obj_.original_tagname_ = 'fft_box'
# end class basisType


class basis_setType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gamma_only=None, ecutwfc=None, ecutrho=None, fft_grid=None, fft_smooth=None, fft_box=None, ngm=None, ngms=None, npwx=None, reciprocal_lattice=None):
        self.original_tagname_ = None
        self.gamma_only = gamma_only
        self.ecutwfc = ecutwfc
        self.ecutrho = ecutrho
        self.fft_grid = fft_grid
        self.fft_smooth = fft_smooth
        self.fft_box = fft_box
        self.ngm = ngm
        self.ngms = ngms
        self.npwx = npwx
        self.reciprocal_lattice = reciprocal_lattice
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basis_setType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basis_setType.subclass:
            return basis_setType.subclass(*args_, **kwargs_)
        else:
            return basis_setType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gamma_only(self): return self.gamma_only
    def set_gamma_only(self, gamma_only): self.gamma_only = gamma_only
    def get_ecutwfc(self): return self.ecutwfc
    def set_ecutwfc(self, ecutwfc): self.ecutwfc = ecutwfc
    def get_ecutrho(self): return self.ecutrho
    def set_ecutrho(self, ecutrho): self.ecutrho = ecutrho
    def get_fft_grid(self): return self.fft_grid
    def set_fft_grid(self, fft_grid): self.fft_grid = fft_grid
    def get_fft_smooth(self): return self.fft_smooth
    def set_fft_smooth(self, fft_smooth): self.fft_smooth = fft_smooth
    def get_fft_box(self): return self.fft_box
    def set_fft_box(self, fft_box): self.fft_box = fft_box
    def get_ngm(self): return self.ngm
    def set_ngm(self, ngm): self.ngm = ngm
    def get_ngms(self): return self.ngms
    def set_ngms(self, ngms): self.ngms = ngms
    def get_npwx(self): return self.npwx
    def set_npwx(self, npwx): self.npwx = npwx
    def get_reciprocal_lattice(self): return self.reciprocal_lattice
    def set_reciprocal_lattice(self, reciprocal_lattice): self.reciprocal_lattice = reciprocal_lattice
    def hasContent_(self):
        if (
            self.gamma_only is not None or
            self.ecutwfc is not None or
            self.ecutrho is not None or
            self.fft_grid is not None or
            self.fft_smooth is not None or
            self.fft_box is not None or
            self.ngm is not None or
            self.ngms is not None or
            self.npwx is not None or
            self.reciprocal_lattice is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='basis_setType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basis_setType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basis_setType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='basis_setType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='basis_setType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='basis_setType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.gamma_only is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:gamma_only>%s</qes:gamma_only>%s' % (self.gds_format_boolean(self.gamma_only, input_name='gamma_only'), eol_))
        if self.ecutwfc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ecutwfc>%s</qes:ecutwfc>%s' % (self.gds_format_double(self.ecutwfc, input_name='ecutwfc'), eol_))
        if self.ecutrho is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ecutrho>%s</qes:ecutrho>%s' % (self.gds_format_double(self.ecutrho, input_name='ecutrho'), eol_))
        if self.fft_grid is not None:
            self.fft_grid.export(outfile, level, namespaceprefix_, name_='fft_grid', pretty_print=pretty_print)
        if self.fft_smooth is not None:
            self.fft_smooth.export(outfile, level, namespaceprefix_, name_='fft_smooth', pretty_print=pretty_print)
        if self.fft_box is not None:
            self.fft_box.export(outfile, level, namespaceprefix_, name_='fft_box', pretty_print=pretty_print)
        if self.ngm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ngm>%s</qes:ngm>%s' % (self.gds_format_integer(self.ngm, input_name='ngm'), eol_))
        if self.ngms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ngms>%s</qes:ngms>%s' % (self.gds_format_integer(self.ngms, input_name='ngms'), eol_))
        if self.npwx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:npwx>%s</qes:npwx>%s' % (self.gds_format_integer(self.npwx, input_name='npwx'), eol_))
        if self.reciprocal_lattice is not None:
            self.reciprocal_lattice.export(outfile, level, namespaceprefix_, name_='reciprocal_lattice', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gamma_only':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'gamma_only')
            self.gamma_only = ival_
        elif nodeName_ == 'ecutwfc' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ecutwfc')
            self.ecutwfc = fval_
        elif nodeName_ == 'ecutrho' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ecutrho')
            self.ecutrho = fval_
        elif nodeName_ == 'fft_grid':
            obj_ = basisSetItemType.factory()
            obj_.build(child_)
            self.fft_grid = obj_
            obj_.original_tagname_ = 'fft_grid'
        elif nodeName_ == 'fft_smooth':
            obj_ = basisSetItemType.factory()
            obj_.build(child_)
            self.fft_smooth = obj_
            obj_.original_tagname_ = 'fft_smooth'
        elif nodeName_ == 'fft_box':
            obj_ = basisSetItemType.factory()
            obj_.build(child_)
            self.fft_box = obj_
            obj_.original_tagname_ = 'fft_box'
        elif nodeName_ == 'ngm' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ngm')
            self.ngm = ival_
        elif nodeName_ == 'ngms' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ngms')
            self.ngms = ival_
        elif nodeName_ == 'npwx' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'npwx')
            self.npwx = ival_
        elif nodeName_ == 'reciprocal_lattice':
            obj_ = reciprocal_latticeType.factory()
            obj_.build(child_)
            self.reciprocal_lattice = obj_
            obj_.original_tagname_ = 'reciprocal_lattice'
# end class basis_setType


class basisSetItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nr1=None, nr2=None, nr3=None, valueOf_=None):
        self.original_tagname_ = None
        self.nr1 = _cast(int, nr1)
        self.nr2 = _cast(int, nr2)
        self.nr3 = _cast(int, nr3)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basisSetItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basisSetItemType.subclass:
            return basisSetItemType.subclass(*args_, **kwargs_)
        else:
            return basisSetItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nr1(self): return self.nr1
    def set_nr1(self, nr1): self.nr1 = nr1
    def get_nr2(self): return self.nr2
    def set_nr2(self, nr2): self.nr2 = nr2
    def get_nr3(self): return self.nr3
    def set_nr3(self, nr3): self.nr3 = nr3
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='basisSetItemType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basisSetItemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basisSetItemType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='basisSetItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='basisSetItemType'):
        if self.nr1 is not None and 'nr1' not in already_processed:
            already_processed.add('nr1')
            outfile.write(' nr1="%s"' % self.gds_format_integer(self.nr1, input_name='nr1'))
        if self.nr2 is not None and 'nr2' not in already_processed:
            already_processed.add('nr2')
            outfile.write(' nr2="%s"' % self.gds_format_integer(self.nr2, input_name='nr2'))
        if self.nr3 is not None and 'nr3' not in already_processed:
            already_processed.add('nr3')
            outfile.write(' nr3="%s"' % self.gds_format_integer(self.nr3, input_name='nr3'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='basisSetItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nr1', node)
        if value is not None and 'nr1' not in already_processed:
            already_processed.add('nr1')
            try:
                self.nr1 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.nr1 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('nr2', node)
        if value is not None and 'nr2' not in already_processed:
            already_processed.add('nr2')
            try:
                self.nr2 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.nr2 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('nr3', node)
        if value is not None and 'nr3' not in already_processed:
            already_processed.add('nr3')
            try:
                self.nr3 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.nr3 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class basisSetItemType


class reciprocal_latticeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, b1=None, b2=None, b3=None):
        self.original_tagname_ = None
        self.b1 = b1
        self.validate_d3vectorType(self.b1)
        self.b2 = b2
        self.validate_d3vectorType(self.b2)
        self.b3 = b3
        self.validate_d3vectorType(self.b3)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reciprocal_latticeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reciprocal_latticeType.subclass:
            return reciprocal_latticeType.subclass(*args_, **kwargs_)
        else:
            return reciprocal_latticeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_b1(self): return self.b1
    def set_b1(self, b1): self.b1 = b1
    def get_b2(self): return self.b2
    def set_b2(self, b2): self.b2 = b2
    def get_b3(self): return self.b3
    def set_b3(self, b3): self.b3 = b3
    def validate_d3vectorType(self, value):
        # Validate type d3vectorType, a restriction on double.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on d3vectorType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.b1 is not None or
            self.b2 is not None or
            self.b3 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='reciprocal_latticeType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('reciprocal_latticeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='reciprocal_latticeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='reciprocal_latticeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='reciprocal_latticeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='reciprocal_latticeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.b1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:b1>%s</qes:b1>%s' % (self.gds_format_double_list(self.b1, input_name='b1'), eol_))
        if self.b2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:b2>%s</qes:b2>%s' % (self.gds_format_double_list(self.b2, input_name='b2'), eol_))
        if self.b3 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:b3>%s</qes:b3>%s' % (self.gds_format_double_list(self.b3, input_name='b3'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'b1':
            b1_ = child_.text
            b1_ = self.gds_validate_double_list(b1_, node, 'b1')
            self.b1 = b1_
            # validate type d3vectorType
            self.validate_d3vectorType(self.b1)
        elif nodeName_ == 'b2':
            b2_ = child_.text
            b2_ = self.gds_validate_double_list(b2_, node, 'b2')
            self.b2 = b2_
            # validate type d3vectorType
            self.validate_d3vectorType(self.b2)
        elif nodeName_ == 'b3':
            b3_ = child_.text
            b3_ = self.gds_validate_double_list(b3_, node, 'b3')
            self.b3 = b3_
            # validate type d3vectorType
            self.validate_d3vectorType(self.b3)
# end class reciprocal_latticeType


class electron_controlType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, diagonalization=None, mixing_mode=None, mixing_beta=None, conv_thr=None, mixing_ndim=None, max_nstep=None, real_space_q=None, tq_smoothing=None, tbeta_smoothing=None, diago_thr_init=None, diago_full_acc=None, diago_cg_maxiter=None, diago_david_ndim=None):
        self.original_tagname_ = None
        self.diagonalization = diagonalization
        self.validate_diagoType(self.diagonalization)
        self.mixing_mode = mixing_mode
        self.validate_mixingModeType(self.mixing_mode)
        self.mixing_beta = mixing_beta
        self.conv_thr = conv_thr
        self.mixing_ndim = mixing_ndim
        self.max_nstep = max_nstep
        self.real_space_q = real_space_q
        self.tq_smoothing = tq_smoothing
        self.tbeta_smoothing = tbeta_smoothing
        self.diago_thr_init = diago_thr_init
        self.diago_full_acc = diago_full_acc
        self.diago_cg_maxiter = diago_cg_maxiter
        self.diago_david_ndim = diago_david_ndim
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, electron_controlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if electron_controlType.subclass:
            return electron_controlType.subclass(*args_, **kwargs_)
        else:
            return electron_controlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_diagonalization(self): return self.diagonalization
    def set_diagonalization(self, diagonalization): self.diagonalization = diagonalization
    def get_mixing_mode(self): return self.mixing_mode
    def set_mixing_mode(self, mixing_mode): self.mixing_mode = mixing_mode
    def get_mixing_beta(self): return self.mixing_beta
    def set_mixing_beta(self, mixing_beta): self.mixing_beta = mixing_beta
    def get_conv_thr(self): return self.conv_thr
    def set_conv_thr(self, conv_thr): self.conv_thr = conv_thr
    def get_mixing_ndim(self): return self.mixing_ndim
    def set_mixing_ndim(self, mixing_ndim): self.mixing_ndim = mixing_ndim
    def get_max_nstep(self): return self.max_nstep
    def set_max_nstep(self, max_nstep): self.max_nstep = max_nstep
    def get_real_space_q(self): return self.real_space_q
    def set_real_space_q(self, real_space_q): self.real_space_q = real_space_q
    def get_tq_smoothing(self): return self.tq_smoothing
    def set_tq_smoothing(self, tq_smoothing): self.tq_smoothing = tq_smoothing
    def get_tbeta_smoothing(self): return self.tbeta_smoothing
    def set_tbeta_smoothing(self, tbeta_smoothing): self.tbeta_smoothing = tbeta_smoothing
    def get_diago_thr_init(self): return self.diago_thr_init
    def set_diago_thr_init(self, diago_thr_init): self.diago_thr_init = diago_thr_init
    def get_diago_full_acc(self): return self.diago_full_acc
    def set_diago_full_acc(self, diago_full_acc): self.diago_full_acc = diago_full_acc
    def get_diago_cg_maxiter(self): return self.diago_cg_maxiter
    def set_diago_cg_maxiter(self, diago_cg_maxiter): self.diago_cg_maxiter = diago_cg_maxiter
    def get_diago_david_ndim(self): return self.diago_david_ndim
    def set_diago_david_ndim(self, diago_david_ndim): self.diago_david_ndim = diago_david_ndim
    def validate_diagoType(self, value):
        # Validate type diagoType, a restriction on string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['davidson', 'cg']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on diagoType' % {"value" : value.encode("utf-8")} )
    def validate_mixingModeType(self, value):
        # Validate type mixingModeType, a restriction on string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['plain', 'TF', 'local-TF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on mixingModeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.diagonalization is not None or
            self.mixing_mode is not None or
            self.mixing_beta is not None or
            self.conv_thr is not None or
            self.mixing_ndim is not None or
            self.max_nstep is not None or
            self.real_space_q is not None or
            self.tq_smoothing is not None or
            self.tbeta_smoothing is not None or
            self.diago_thr_init is not None or
            self.diago_full_acc is not None or
            self.diago_cg_maxiter is not None or
            self.diago_david_ndim is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='electron_controlType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('electron_controlType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='electron_controlType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='electron_controlType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='electron_controlType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='electron_controlType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.diagonalization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:diagonalization>%s</qes:diagonalization>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.diagonalization), input_name='diagonalization')), eol_))
        if self.mixing_mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:mixing_mode>%s</qes:mixing_mode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.mixing_mode), input_name='mixing_mode')), eol_))
        if self.mixing_beta is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:mixing_beta>%s</qes:mixing_beta>%s' % (self.gds_format_double(self.mixing_beta, input_name='mixing_beta'), eol_))
        if self.conv_thr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:conv_thr>%s</qes:conv_thr>%s' % (self.gds_format_double(self.conv_thr, input_name='conv_thr'), eol_))
        if self.mixing_ndim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:mixing_ndim>%s</qes:mixing_ndim>%s' % (self.gds_format_integer(self.mixing_ndim, input_name='mixing_ndim'), eol_))
        if self.max_nstep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:max_nstep>%s</qes:max_nstep>%s' % (self.gds_format_integer(self.max_nstep, input_name='max_nstep'), eol_))
        if self.real_space_q is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:real_space_q>%s</qes:real_space_q>%s' % (self.gds_format_boolean(self.real_space_q, input_name='real_space_q'), eol_))
        if self.tq_smoothing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:tq_smoothing>%s</qes:tq_smoothing>%s' % (self.gds_format_boolean(self.tq_smoothing, input_name='tq_smoothing'), eol_))
        if self.tbeta_smoothing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:tbeta_smoothing>%s</qes:tbeta_smoothing>%s' % (self.gds_format_boolean(self.tbeta_smoothing, input_name='tbeta_smoothing'), eol_))
        if self.diago_thr_init is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:diago_thr_init>%s</qes:diago_thr_init>%s' % (self.gds_format_double(self.diago_thr_init, input_name='diago_thr_init'), eol_))
        if self.diago_full_acc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:diago_full_acc>%s</qes:diago_full_acc>%s' % (self.gds_format_boolean(self.diago_full_acc, input_name='diago_full_acc'), eol_))
        if self.diago_cg_maxiter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:diago_cg_maxiter>%s</qes:diago_cg_maxiter>%s' % (self.gds_format_integer(self.diago_cg_maxiter, input_name='diago_cg_maxiter'), eol_))
        if self.diago_david_ndim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:diago_david_ndim>%s</qes:diago_david_ndim>%s' % (self.gds_format_integer(self.diago_david_ndim, input_name='diago_david_ndim'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'diagonalization':
            diagonalization_ = child_.text
            diagonalization_ = self.gds_validate_string(diagonalization_, node, 'diagonalization')
            self.diagonalization = diagonalization_
            # validate type diagoType
            self.validate_diagoType(self.diagonalization)
        elif nodeName_ == 'mixing_mode':
            mixing_mode_ = child_.text
            mixing_mode_ = self.gds_validate_string(mixing_mode_, node, 'mixing_mode')
            self.mixing_mode = mixing_mode_
            # validate type mixingModeType
            self.validate_mixingModeType(self.mixing_mode)
        elif nodeName_ == 'mixing_beta' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'mixing_beta')
            self.mixing_beta = fval_
        elif nodeName_ == 'conv_thr' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'conv_thr')
            self.conv_thr = fval_
        elif nodeName_ == 'mixing_ndim' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'mixing_ndim')
            self.mixing_ndim = ival_
        elif nodeName_ == 'max_nstep' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'max_nstep')
            self.max_nstep = ival_
        elif nodeName_ == 'real_space_q':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'real_space_q')
            self.real_space_q = ival_
        elif nodeName_ == 'tq_smoothing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'tq_smoothing')
            self.tq_smoothing = ival_
        elif nodeName_ == 'tbeta_smoothing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'tbeta_smoothing')
            self.tbeta_smoothing = ival_
        elif nodeName_ == 'diago_thr_init' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'diago_thr_init')
            self.diago_thr_init = fval_
        elif nodeName_ == 'diago_full_acc':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'diago_full_acc')
            self.diago_full_acc = ival_
        elif nodeName_ == 'diago_cg_maxiter' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'diago_cg_maxiter')
            self.diago_cg_maxiter = ival_
        elif nodeName_ == 'diago_david_ndim' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'diago_david_ndim')
            self.diago_david_ndim = ival_
# end class electron_controlType


class k_points_IBZType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, monkhorst_pack=None, nk=None, k_point=None):
        self.original_tagname_ = None
        self.monkhorst_pack = monkhorst_pack
        self.nk = nk
        if k_point is None:
            self.k_point = []
        else:
            self.k_point = k_point
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, k_points_IBZType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if k_points_IBZType.subclass:
            return k_points_IBZType.subclass(*args_, **kwargs_)
        else:
            return k_points_IBZType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monkhorst_pack(self): return self.monkhorst_pack
    def set_monkhorst_pack(self, monkhorst_pack): self.monkhorst_pack = monkhorst_pack
    def get_nk(self): return self.nk
    def set_nk(self, nk): self.nk = nk
    def get_k_point(self): return self.k_point
    def set_k_point(self, k_point): self.k_point = k_point
    def add_k_point(self, value): self.k_point.append(value)
    def insert_k_point_at(self, index, value): self.k_point.insert(index, value)
    def replace_k_point_at(self, index, value): self.k_point[index] = value
    def hasContent_(self):
        if (
            self.monkhorst_pack is not None or
            self.nk is not None or
            self.k_point
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='k_points_IBZType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('k_points_IBZType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='k_points_IBZType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='k_points_IBZType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='k_points_IBZType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='k_points_IBZType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.monkhorst_pack is not None:
            self.monkhorst_pack.export(outfile, level, namespaceprefix_, name_='monkhorst_pack', pretty_print=pretty_print)
        if self.nk is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nk>%s</qes:nk>%s' % (self.gds_format_integer(self.nk, input_name='nk'), eol_))
        for k_point_ in self.k_point:
            k_point_.export(outfile, level, namespaceprefix_, name_='k_point', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monkhorst_pack':
            obj_ = monkhorst_packType.factory()
            obj_.build(child_)
            self.monkhorst_pack = obj_
            obj_.original_tagname_ = 'monkhorst_pack'
        elif nodeName_ == 'nk' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nk')
            self.nk = ival_
        elif nodeName_ == 'k_point':
            obj_ = k_pointType.factory()
            obj_.build(child_)
            self.k_point.append(obj_)
            obj_.original_tagname_ = 'k_point'
# end class k_points_IBZType


class monkhorst_packType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nk1=None, nk2=None, nk3=None, k1=None, k2=None, k3=None, valueOf_=None):
        self.original_tagname_ = None
        self.nk1 = _cast(int, nk1)
        self.nk2 = _cast(int, nk2)
        self.nk3 = _cast(int, nk3)
        self.k1 = _cast(int, k1)
        self.k2 = _cast(int, k2)
        self.k3 = _cast(int, k3)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monkhorst_packType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monkhorst_packType.subclass:
            return monkhorst_packType.subclass(*args_, **kwargs_)
        else:
            return monkhorst_packType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nk1(self): return self.nk1
    def set_nk1(self, nk1): self.nk1 = nk1
    def get_nk2(self): return self.nk2
    def set_nk2(self, nk2): self.nk2 = nk2
    def get_nk3(self): return self.nk3
    def set_nk3(self, nk3): self.nk3 = nk3
    def get_k1(self): return self.k1
    def set_k1(self, k1): self.k1 = k1
    def get_k2(self): return self.k2
    def set_k2(self, k2): self.k2 = k2
    def get_k3(self): return self.k3
    def set_k3(self, k3): self.k3 = k3
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='monkhorst_packType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monkhorst_packType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='monkhorst_packType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='monkhorst_packType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='monkhorst_packType'):
        if self.nk1 is not None and 'nk1' not in already_processed:
            already_processed.add('nk1')
            outfile.write(' nk1="%s"' % self.gds_format_integer(self.nk1, input_name='nk1'))
        if self.nk2 is not None and 'nk2' not in already_processed:
            already_processed.add('nk2')
            outfile.write(' nk2="%s"' % self.gds_format_integer(self.nk2, input_name='nk2'))
        if self.nk3 is not None and 'nk3' not in already_processed:
            already_processed.add('nk3')
            outfile.write(' nk3="%s"' % self.gds_format_integer(self.nk3, input_name='nk3'))
        if self.k1 is not None and 'k1' not in already_processed:
            already_processed.add('k1')
            outfile.write(' k1="%s"' % self.gds_format_integer(self.k1, input_name='k1'))
        if self.k2 is not None and 'k2' not in already_processed:
            already_processed.add('k2')
            outfile.write(' k2="%s"' % self.gds_format_integer(self.k2, input_name='k2'))
        if self.k3 is not None and 'k3' not in already_processed:
            already_processed.add('k3')
            outfile.write(' k3="%s"' % self.gds_format_integer(self.k3, input_name='k3'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='monkhorst_packType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nk1', node)
        if value is not None and 'nk1' not in already_processed:
            already_processed.add('nk1')
            try:
                self.nk1 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.nk1 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('nk2', node)
        if value is not None and 'nk2' not in already_processed:
            already_processed.add('nk2')
            try:
                self.nk2 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.nk2 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('nk3', node)
        if value is not None and 'nk3' not in already_processed:
            already_processed.add('nk3')
            try:
                self.nk3 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.nk3 <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('k1', node)
        if value is not None and 'k1' not in already_processed:
            already_processed.add('k1')
            try:
                self.k1 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.k1 < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('k2', node)
        if value is not None and 'k2' not in already_processed:
            already_processed.add('k2')
            try:
                self.k2 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.k2 < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('k3', node)
        if value is not None and 'k3' not in already_processed:
            already_processed.add('k3')
            try:
                self.k3 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.k3 < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class monkhorst_packType


class k_pointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, weight=None, label=None, valueOf_=None):
        self.original_tagname_ = None
        self.weight = _cast(float, weight)
        self.label = _cast(None, label)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, k_pointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if k_pointType.subclass:
            return k_pointType.subclass(*args_, **kwargs_)
        else:
            return k_pointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='k_pointType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('k_pointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='k_pointType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='k_pointType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='k_pointType'):
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight="%s"' % self.gds_format_double(self.weight, input_name='weight'))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='k_pointType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            try:
                self.weight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (weight): %s' % exp)
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class k_pointType


class ion_controlType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ion_dynamics=None, upscale=None, remove_rigid_rot=None, refold_pos=None, bfgs=None, md=None):
        self.original_tagname_ = None
        self.ion_dynamics = ion_dynamics
        self.upscale = upscale
        self.remove_rigid_rot = remove_rigid_rot
        self.refold_pos = refold_pos
        self.bfgs = bfgs
        self.md = md
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ion_controlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ion_controlType.subclass:
            return ion_controlType.subclass(*args_, **kwargs_)
        else:
            return ion_controlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ion_dynamics(self): return self.ion_dynamics
    def set_ion_dynamics(self, ion_dynamics): self.ion_dynamics = ion_dynamics
    def get_upscale(self): return self.upscale
    def set_upscale(self, upscale): self.upscale = upscale
    def get_remove_rigid_rot(self): return self.remove_rigid_rot
    def set_remove_rigid_rot(self, remove_rigid_rot): self.remove_rigid_rot = remove_rigid_rot
    def get_refold_pos(self): return self.refold_pos
    def set_refold_pos(self, refold_pos): self.refold_pos = refold_pos
    def get_bfgs(self): return self.bfgs
    def set_bfgs(self, bfgs): self.bfgs = bfgs
    def get_md(self): return self.md
    def set_md(self, md): self.md = md
    def hasContent_(self):
        if (
            self.ion_dynamics is not None or
            self.upscale is not None or
            self.remove_rigid_rot is not None or
            self.refold_pos is not None or
            self.bfgs is not None or
            self.md is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='ion_controlType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ion_controlType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ion_controlType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='ion_controlType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='ion_controlType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='ion_controlType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ion_dynamics is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ion_dynamics>%s</qes:ion_dynamics>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ion_dynamics), input_name='ion_dynamics')), eol_))
        if self.upscale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:upscale>%s</qes:upscale>%s' % (self.gds_format_double(self.upscale, input_name='upscale'), eol_))
        if self.remove_rigid_rot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:remove_rigid_rot>%s</qes:remove_rigid_rot>%s' % (self.gds_format_boolean(self.remove_rigid_rot, input_name='remove_rigid_rot'), eol_))
        if self.refold_pos is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:refold_pos>%s</qes:refold_pos>%s' % (self.gds_format_boolean(self.refold_pos, input_name='refold_pos'), eol_))
        if self.bfgs is not None:
            self.bfgs.export(outfile, level, namespaceprefix_, name_='bfgs', pretty_print=pretty_print)
        if self.md is not None:
            self.md.export(outfile, level, namespaceprefix_, name_='md', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ion_dynamics':
            ion_dynamics_ = child_.text
            ion_dynamics_ = self.gds_validate_string(ion_dynamics_, node, 'ion_dynamics')
            self.ion_dynamics = ion_dynamics_
        elif nodeName_ == 'upscale' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'upscale')
            self.upscale = fval_
        elif nodeName_ == 'remove_rigid_rot':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'remove_rigid_rot')
            self.remove_rigid_rot = ival_
        elif nodeName_ == 'refold_pos':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'refold_pos')
            self.refold_pos = ival_
        elif nodeName_ == 'bfgs':
            obj_ = bfgsType.factory()
            obj_.build(child_)
            self.bfgs = obj_
            obj_.original_tagname_ = 'bfgs'
        elif nodeName_ == 'md':
            obj_ = mdType.factory()
            obj_.build(child_)
            self.md = obj_
            obj_.original_tagname_ = 'md'
# end class ion_controlType


class bfgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ndim=None, trust_radius_min=None, trust_radius_max=None, trust_radius_init=None, w1=None, w2=None):
        self.original_tagname_ = None
        self.ndim = ndim
        self.trust_radius_min = trust_radius_min
        self.trust_radius_max = trust_radius_max
        self.trust_radius_init = trust_radius_init
        self.w1 = w1
        self.w2 = w2
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bfgsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bfgsType.subclass:
            return bfgsType.subclass(*args_, **kwargs_)
        else:
            return bfgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ndim(self): return self.ndim
    def set_ndim(self, ndim): self.ndim = ndim
    def get_trust_radius_min(self): return self.trust_radius_min
    def set_trust_radius_min(self, trust_radius_min): self.trust_radius_min = trust_radius_min
    def get_trust_radius_max(self): return self.trust_radius_max
    def set_trust_radius_max(self, trust_radius_max): self.trust_radius_max = trust_radius_max
    def get_trust_radius_init(self): return self.trust_radius_init
    def set_trust_radius_init(self, trust_radius_init): self.trust_radius_init = trust_radius_init
    def get_w1(self): return self.w1
    def set_w1(self, w1): self.w1 = w1
    def get_w2(self): return self.w2
    def set_w2(self, w2): self.w2 = w2
    def hasContent_(self):
        if (
            self.ndim is not None or
            self.trust_radius_min is not None or
            self.trust_radius_max is not None or
            self.trust_radius_init is not None or
            self.w1 is not None or
            self.w2 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='bfgsType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bfgsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bfgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='bfgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='bfgsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='bfgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ndim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ndim>%s</qes:ndim>%s' % (self.gds_format_integer(self.ndim, input_name='ndim'), eol_))
        if self.trust_radius_min is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:trust_radius_min>%s</qes:trust_radius_min>%s' % (self.gds_format_double(self.trust_radius_min, input_name='trust_radius_min'), eol_))
        if self.trust_radius_max is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:trust_radius_max>%s</qes:trust_radius_max>%s' % (self.gds_format_double(self.trust_radius_max, input_name='trust_radius_max'), eol_))
        if self.trust_radius_init is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:trust_radius_init>%s</qes:trust_radius_init>%s' % (self.gds_format_double(self.trust_radius_init, input_name='trust_radius_init'), eol_))
        if self.w1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:w1>%s</qes:w1>%s' % (self.gds_format_double(self.w1, input_name='w1'), eol_))
        if self.w2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:w2>%s</qes:w2>%s' % (self.gds_format_double(self.w2, input_name='w2'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ndim' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ndim')
            self.ndim = ival_
        elif nodeName_ == 'trust_radius_min' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'trust_radius_min')
            self.trust_radius_min = fval_
        elif nodeName_ == 'trust_radius_max' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'trust_radius_max')
            self.trust_radius_max = fval_
        elif nodeName_ == 'trust_radius_init' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'trust_radius_init')
            self.trust_radius_init = fval_
        elif nodeName_ == 'w1' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'w1')
            self.w1 = fval_
        elif nodeName_ == 'w2' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'w2')
            self.w2 = fval_
# end class bfgsType


class mdType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pot_extrapolation=None, wfc_extrapolation=None, ion_temperature=None, timestep=20.0, tempw=None, tolp=None, deltaT=None, nraise=None):
        self.original_tagname_ = None
        self.pot_extrapolation = pot_extrapolation
        self.wfc_extrapolation = wfc_extrapolation
        self.ion_temperature = ion_temperature
        self.timestep = timestep
        self.tempw = tempw
        self.tolp = tolp
        self.deltaT = deltaT
        self.nraise = nraise
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mdType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mdType.subclass:
            return mdType.subclass(*args_, **kwargs_)
        else:
            return mdType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pot_extrapolation(self): return self.pot_extrapolation
    def set_pot_extrapolation(self, pot_extrapolation): self.pot_extrapolation = pot_extrapolation
    def get_wfc_extrapolation(self): return self.wfc_extrapolation
    def set_wfc_extrapolation(self, wfc_extrapolation): self.wfc_extrapolation = wfc_extrapolation
    def get_ion_temperature(self): return self.ion_temperature
    def set_ion_temperature(self, ion_temperature): self.ion_temperature = ion_temperature
    def get_timestep(self): return self.timestep
    def set_timestep(self, timestep): self.timestep = timestep
    def get_tempw(self): return self.tempw
    def set_tempw(self, tempw): self.tempw = tempw
    def get_tolp(self): return self.tolp
    def set_tolp(self, tolp): self.tolp = tolp
    def get_deltaT(self): return self.deltaT
    def set_deltaT(self, deltaT): self.deltaT = deltaT
    def get_nraise(self): return self.nraise
    def set_nraise(self, nraise): self.nraise = nraise
    def hasContent_(self):
        if (
            self.pot_extrapolation is not None or
            self.wfc_extrapolation is not None or
            self.ion_temperature is not None or
            self.timestep != 20.0 or
            self.tempw is not None or
            self.tolp is not None or
            self.deltaT is not None or
            self.nraise is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='mdType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mdType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mdType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='mdType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='mdType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='mdType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pot_extrapolation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:pot_extrapolation>%s</qes:pot_extrapolation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pot_extrapolation), input_name='pot_extrapolation')), eol_))
        if self.wfc_extrapolation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:wfc_extrapolation>%s</qes:wfc_extrapolation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.wfc_extrapolation), input_name='wfc_extrapolation')), eol_))
        if self.ion_temperature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ion_temperature>%s</qes:ion_temperature>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ion_temperature), input_name='ion_temperature')), eol_))
        if self.timestep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:timestep>%s</qes:timestep>%s' % (self.gds_format_double(self.timestep, input_name='timestep'), eol_))
        if self.tempw is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:tempw>%s</qes:tempw>%s' % (self.gds_format_double(self.tempw, input_name='tempw'), eol_))
        if self.tolp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:tolp>%s</qes:tolp>%s' % (self.gds_format_double(self.tolp, input_name='tolp'), eol_))
        if self.deltaT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:deltaT>%s</qes:deltaT>%s' % (self.gds_format_double(self.deltaT, input_name='deltaT'), eol_))
        if self.nraise is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nraise>%s</qes:nraise>%s' % (self.gds_format_integer(self.nraise, input_name='nraise'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pot_extrapolation':
            pot_extrapolation_ = child_.text
            pot_extrapolation_ = self.gds_validate_string(pot_extrapolation_, node, 'pot_extrapolation')
            self.pot_extrapolation = pot_extrapolation_
        elif nodeName_ == 'wfc_extrapolation':
            wfc_extrapolation_ = child_.text
            wfc_extrapolation_ = self.gds_validate_string(wfc_extrapolation_, node, 'wfc_extrapolation')
            self.wfc_extrapolation = wfc_extrapolation_
        elif nodeName_ == 'ion_temperature':
            ion_temperature_ = child_.text
            ion_temperature_ = self.gds_validate_string(ion_temperature_, node, 'ion_temperature')
            self.ion_temperature = ion_temperature_
        elif nodeName_ == 'timestep' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'timestep')
            self.timestep = fval_
        elif nodeName_ == 'tempw' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'tempw')
            self.tempw = fval_
        elif nodeName_ == 'tolp' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'tolp')
            self.tolp = fval_
        elif nodeName_ == 'deltaT' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'deltaT')
            self.deltaT = fval_
        elif nodeName_ == 'nraise' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nraise')
            self.nraise = ival_
# end class mdType


class cell_controlType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cell_dynamics=None, pressure=0.0, wmass=None, cell_factor=None, fix_volume=None, fix_area=None, fix_xy=None, isotropic=None, free_cell=None):
        self.original_tagname_ = None
        self.cell_dynamics = cell_dynamics
        self.pressure = pressure
        self.wmass = wmass
        self.cell_factor = cell_factor
        self.fix_volume = fix_volume
        self.fix_area = fix_area
        self.fix_xy = fix_xy
        self.isotropic = isotropic
        self.free_cell = free_cell
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cell_controlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cell_controlType.subclass:
            return cell_controlType.subclass(*args_, **kwargs_)
        else:
            return cell_controlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cell_dynamics(self): return self.cell_dynamics
    def set_cell_dynamics(self, cell_dynamics): self.cell_dynamics = cell_dynamics
    def get_pressure(self): return self.pressure
    def set_pressure(self, pressure): self.pressure = pressure
    def get_wmass(self): return self.wmass
    def set_wmass(self, wmass): self.wmass = wmass
    def get_cell_factor(self): return self.cell_factor
    def set_cell_factor(self, cell_factor): self.cell_factor = cell_factor
    def get_fix_volume(self): return self.fix_volume
    def set_fix_volume(self, fix_volume): self.fix_volume = fix_volume
    def get_fix_area(self): return self.fix_area
    def set_fix_area(self, fix_area): self.fix_area = fix_area
    def get_fix_xy(self): return self.fix_xy
    def set_fix_xy(self, fix_xy): self.fix_xy = fix_xy
    def get_isotropic(self): return self.isotropic
    def set_isotropic(self, isotropic): self.isotropic = isotropic
    def get_free_cell(self): return self.free_cell
    def set_free_cell(self, free_cell): self.free_cell = free_cell
    def hasContent_(self):
        if (
            self.cell_dynamics is not None or
            self.pressure != 0.0 or
            self.wmass is not None or
            self.cell_factor is not None or
            self.fix_volume is not None or
            self.fix_area is not None or
            self.fix_xy is not None or
            self.isotropic is not None or
            self.free_cell is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='cell_controlType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cell_controlType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cell_controlType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='cell_controlType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='cell_controlType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='cell_controlType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cell_dynamics is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:cell_dynamics>%s</qes:cell_dynamics>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cell_dynamics), input_name='cell_dynamics')), eol_))
        if self.pressure is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:pressure>%s</qes:pressure>%s' % (self.gds_format_double(self.pressure, input_name='pressure'), eol_))
        if self.wmass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:wmass>%s</qes:wmass>%s' % (self.gds_format_double(self.wmass, input_name='wmass'), eol_))
        if self.cell_factor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:cell_factor>%s</qes:cell_factor>%s' % (self.gds_format_double(self.cell_factor, input_name='cell_factor'), eol_))
        if self.fix_volume is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:fix_volume>%s</qes:fix_volume>%s' % (self.gds_format_boolean(self.fix_volume, input_name='fix_volume'), eol_))
        if self.fix_area is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:fix_area>%s</qes:fix_area>%s' % (self.gds_format_boolean(self.fix_area, input_name='fix_area'), eol_))
        if self.fix_xy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:fix_xy>%s</qes:fix_xy>%s' % (self.gds_format_boolean(self.fix_xy, input_name='fix_xy'), eol_))
        if self.isotropic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:isotropic>%s</qes:isotropic>%s' % (self.gds_format_boolean(self.isotropic, input_name='isotropic'), eol_))
        if self.free_cell is not None:
            self.free_cell.export(outfile, level, namespaceprefix_, name_='free_cell', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cell_dynamics':
            cell_dynamics_ = child_.text
            cell_dynamics_ = self.gds_validate_string(cell_dynamics_, node, 'cell_dynamics')
            self.cell_dynamics = cell_dynamics_
        elif nodeName_ == 'pressure' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'pressure')
            self.pressure = fval_
        elif nodeName_ == 'wmass' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'wmass')
            self.wmass = fval_
        elif nodeName_ == 'cell_factor' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'cell_factor')
            self.cell_factor = fval_
        elif nodeName_ == 'fix_volume':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fix_volume')
            self.fix_volume = ival_
        elif nodeName_ == 'fix_area':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fix_area')
            self.fix_area = ival_
        elif nodeName_ == 'fix_xy':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fix_xy')
            self.fix_xy = ival_
        elif nodeName_ == 'isotropic':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isotropic')
            self.isotropic = ival_
        elif nodeName_ == 'free_cell':
            obj_ = integerMatrixType.factory()
            obj_.build(child_)
            self.free_cell = obj_
            obj_.original_tagname_ = 'free_cell'
# end class cell_controlType


class symmetry_flagsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nosym=None, nosym_evc=None, noinv=None, no_t_rev=None, force_symmorphic=None, use_all_frac=None):
        self.original_tagname_ = None
        self.nosym = nosym
        self.nosym_evc = nosym_evc
        self.noinv = noinv
        self.no_t_rev = no_t_rev
        self.force_symmorphic = force_symmorphic
        self.use_all_frac = use_all_frac
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, symmetry_flagsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if symmetry_flagsType.subclass:
            return symmetry_flagsType.subclass(*args_, **kwargs_)
        else:
            return symmetry_flagsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nosym(self): return self.nosym
    def set_nosym(self, nosym): self.nosym = nosym
    def get_nosym_evc(self): return self.nosym_evc
    def set_nosym_evc(self, nosym_evc): self.nosym_evc = nosym_evc
    def get_noinv(self): return self.noinv
    def set_noinv(self, noinv): self.noinv = noinv
    def get_no_t_rev(self): return self.no_t_rev
    def set_no_t_rev(self, no_t_rev): self.no_t_rev = no_t_rev
    def get_force_symmorphic(self): return self.force_symmorphic
    def set_force_symmorphic(self, force_symmorphic): self.force_symmorphic = force_symmorphic
    def get_use_all_frac(self): return self.use_all_frac
    def set_use_all_frac(self, use_all_frac): self.use_all_frac = use_all_frac
    def hasContent_(self):
        if (
            self.nosym is not None or
            self.nosym_evc is not None or
            self.noinv is not None or
            self.no_t_rev is not None or
            self.force_symmorphic is not None or
            self.use_all_frac is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='symmetry_flagsType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('symmetry_flagsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='symmetry_flagsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='symmetry_flagsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='symmetry_flagsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='symmetry_flagsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nosym is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nosym>%s</qes:nosym>%s' % (self.gds_format_boolean(self.nosym, input_name='nosym'), eol_))
        if self.nosym_evc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nosym_evc>%s</qes:nosym_evc>%s' % (self.gds_format_boolean(self.nosym_evc, input_name='nosym_evc'), eol_))
        if self.noinv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:noinv>%s</qes:noinv>%s' % (self.gds_format_boolean(self.noinv, input_name='noinv'), eol_))
        if self.no_t_rev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:no_t_rev>%s</qes:no_t_rev>%s' % (self.gds_format_boolean(self.no_t_rev, input_name='no_t_rev'), eol_))
        if self.force_symmorphic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:force_symmorphic>%s</qes:force_symmorphic>%s' % (self.gds_format_boolean(self.force_symmorphic, input_name='force_symmorphic'), eol_))
        if self.use_all_frac is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:use_all_frac>%s</qes:use_all_frac>%s' % (self.gds_format_boolean(self.use_all_frac, input_name='use_all_frac'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nosym':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'nosym')
            self.nosym = ival_
        elif nodeName_ == 'nosym_evc':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'nosym_evc')
            self.nosym_evc = ival_
        elif nodeName_ == 'noinv':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'noinv')
            self.noinv = ival_
        elif nodeName_ == 'no_t_rev':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'no_t_rev')
            self.no_t_rev = ival_
        elif nodeName_ == 'force_symmorphic':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'force_symmorphic')
            self.force_symmorphic = ival_
        elif nodeName_ == 'use_all_frac':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'use_all_frac')
            self.use_all_frac = ival_
# end class symmetry_flagsType


class boundary_conditionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, assume_isolated=None, esm=None, fcp_opt=None, fcp_mu=None):
        self.original_tagname_ = None
        self.assume_isolated = assume_isolated
        self.esm = esm
        self.fcp_opt = fcp_opt
        self.fcp_mu = fcp_mu
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, boundary_conditionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if boundary_conditionsType.subclass:
            return boundary_conditionsType.subclass(*args_, **kwargs_)
        else:
            return boundary_conditionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assume_isolated(self): return self.assume_isolated
    def set_assume_isolated(self, assume_isolated): self.assume_isolated = assume_isolated
    def get_esm(self): return self.esm
    def set_esm(self, esm): self.esm = esm
    def get_fcp_opt(self): return self.fcp_opt
    def set_fcp_opt(self, fcp_opt): self.fcp_opt = fcp_opt
    def get_fcp_mu(self): return self.fcp_mu
    def set_fcp_mu(self, fcp_mu): self.fcp_mu = fcp_mu
    def hasContent_(self):
        if (
            self.assume_isolated is not None or
            self.esm is not None or
            self.fcp_opt is not None or
            self.fcp_mu is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='boundary_conditionsType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('boundary_conditionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='boundary_conditionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='boundary_conditionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='boundary_conditionsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='boundary_conditionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.assume_isolated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:assume_isolated>%s</qes:assume_isolated>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.assume_isolated), input_name='assume_isolated')), eol_))
        if self.esm is not None:
            self.esm.export(outfile, level, namespaceprefix_, name_='esm', pretty_print=pretty_print)
        if self.fcp_opt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:fcp_opt>%s</qes:fcp_opt>%s' % (self.gds_format_boolean(self.fcp_opt, input_name='fcp_opt'), eol_))
        if self.fcp_mu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:fcp_mu>%s</qes:fcp_mu>%s' % (self.gds_format_double(self.fcp_mu, input_name='fcp_mu'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'assume_isolated':
            assume_isolated_ = child_.text
            assume_isolated_ = self.gds_validate_string(assume_isolated_, node, 'assume_isolated')
            self.assume_isolated = assume_isolated_
        elif nodeName_ == 'esm':
            obj_ = esmType.factory()
            obj_.build(child_)
            self.esm = obj_
            obj_.original_tagname_ = 'esm'
        elif nodeName_ == 'fcp_opt':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fcp_opt')
            self.fcp_opt = ival_
        elif nodeName_ == 'fcp_mu' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fcp_mu')
            self.fcp_mu = fval_
# end class boundary_conditionsType


class esmType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bc=None, nfit=None, w=None, efield=None):
        self.original_tagname_ = None
        self.bc = bc
        self.nfit = nfit
        self.w = w
        self.efield = efield
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, esmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if esmType.subclass:
            return esmType.subclass(*args_, **kwargs_)
        else:
            return esmType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bc(self): return self.bc
    def set_bc(self, bc): self.bc = bc
    def get_nfit(self): return self.nfit
    def set_nfit(self, nfit): self.nfit = nfit
    def get_w(self): return self.w
    def set_w(self, w): self.w = w
    def get_efield(self): return self.efield
    def set_efield(self, efield): self.efield = efield
    def hasContent_(self):
        if (
            self.bc is not None or
            self.nfit is not None or
            self.w is not None or
            self.efield is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='esmType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('esmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='esmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='esmType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='esmType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='esmType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:bc>%s</qes:bc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.bc), input_name='bc')), eol_))
        if self.nfit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nfit>%s</qes:nfit>%s' % (self.gds_format_integer(self.nfit, input_name='nfit'), eol_))
        if self.w is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:w>%s</qes:w>%s' % (self.gds_format_double(self.w, input_name='w'), eol_))
        if self.efield is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:efield>%s</qes:efield>%s' % (self.gds_format_double(self.efield, input_name='efield'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bc':
            bc_ = child_.text
            bc_ = self.gds_validate_string(bc_, node, 'bc')
            self.bc = bc_
        elif nodeName_ == 'nfit' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nfit')
            self.nfit = ival_
        elif nodeName_ == 'w' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'w')
            self.w = fval_
        elif nodeName_ == 'efield' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'efield')
            self.efield = fval_
# end class esmType


class ekin_functionalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ecfixed=None, qcutz=None, q2sigma=None):
        self.original_tagname_ = None
        self.ecfixed = ecfixed
        self.qcutz = qcutz
        self.q2sigma = q2sigma
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ekin_functionalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ekin_functionalType.subclass:
            return ekin_functionalType.subclass(*args_, **kwargs_)
        else:
            return ekin_functionalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ecfixed(self): return self.ecfixed
    def set_ecfixed(self, ecfixed): self.ecfixed = ecfixed
    def get_qcutz(self): return self.qcutz
    def set_qcutz(self, qcutz): self.qcutz = qcutz
    def get_q2sigma(self): return self.q2sigma
    def set_q2sigma(self, q2sigma): self.q2sigma = q2sigma
    def hasContent_(self):
        if (
            self.ecfixed is not None or
            self.qcutz is not None or
            self.q2sigma is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='ekin_functionalType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ekin_functionalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ekin_functionalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='ekin_functionalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='ekin_functionalType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='ekin_functionalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ecfixed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ecfixed>%s</qes:ecfixed>%s' % (self.gds_format_double(self.ecfixed, input_name='ecfixed'), eol_))
        if self.qcutz is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:qcutz>%s</qes:qcutz>%s' % (self.gds_format_double(self.qcutz, input_name='qcutz'), eol_))
        if self.q2sigma is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:q2sigma>%s</qes:q2sigma>%s' % (self.gds_format_double(self.q2sigma, input_name='q2sigma'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ecfixed' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ecfixed')
            self.ecfixed = fval_
        elif nodeName_ == 'qcutz' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'qcutz')
            self.qcutz = fval_
        elif nodeName_ == 'q2sigma' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'q2sigma')
            self.q2sigma = fval_
# end class ekin_functionalType


class spin_constraintsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, spin_constraints=None, lagrange_multiplier=None, target_magnetization=None):
        self.original_tagname_ = None
        self.spin_constraints = spin_constraints
        self.lagrange_multiplier = lagrange_multiplier
        self.target_magnetization = target_magnetization
        self.validate_d3vectorType(self.target_magnetization)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, spin_constraintsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if spin_constraintsType.subclass:
            return spin_constraintsType.subclass(*args_, **kwargs_)
        else:
            return spin_constraintsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spin_constraints(self): return self.spin_constraints
    def set_spin_constraints(self, spin_constraints): self.spin_constraints = spin_constraints
    def get_lagrange_multiplier(self): return self.lagrange_multiplier
    def set_lagrange_multiplier(self, lagrange_multiplier): self.lagrange_multiplier = lagrange_multiplier
    def get_target_magnetization(self): return self.target_magnetization
    def set_target_magnetization(self, target_magnetization): self.target_magnetization = target_magnetization
    def validate_d3vectorType(self, value):
        # Validate type d3vectorType, a restriction on double.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on d3vectorType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.spin_constraints is not None or
            self.lagrange_multiplier is not None or
            self.target_magnetization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='spin_constraintsType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('spin_constraintsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='spin_constraintsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='spin_constraintsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='spin_constraintsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='spin_constraintsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.spin_constraints is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:spin_constraints>%s</qes:spin_constraints>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.spin_constraints), input_name='spin_constraints')), eol_))
        if self.lagrange_multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:lagrange_multiplier>%s</qes:lagrange_multiplier>%s' % (self.gds_format_double(self.lagrange_multiplier, input_name='lagrange_multiplier'), eol_))
        if self.target_magnetization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:target_magnetization>%s</qes:target_magnetization>%s' % (self.gds_format_double_list(self.target_magnetization, input_name='target_magnetization'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'spin_constraints':
            spin_constraints_ = child_.text
            spin_constraints_ = self.gds_validate_string(spin_constraints_, node, 'spin_constraints')
            self.spin_constraints = spin_constraints_
        elif nodeName_ == 'lagrange_multiplier' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'lagrange_multiplier')
            self.lagrange_multiplier = fval_
        elif nodeName_ == 'target_magnetization':
            target_magnetization_ = child_.text
            target_magnetization_ = self.gds_validate_double_list(target_magnetization_, node, 'target_magnetization')
            self.target_magnetization = target_magnetization_
            # validate type d3vectorType
            self.validate_d3vectorType(self.target_magnetization)
# end class spin_constraintsType


class electric_fieldType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, electric_potential=None, dipole_correction=False, gate_settings=None, electric_field_direction=None, potential_max_position=None, potential_decrease_width=None, electric_field_amplitude=None, electric_field_vector=None, nk_per_string=None, n_berry_cycles=None):
        self.original_tagname_ = None
        self.electric_potential = electric_potential
        self.validate_electric_potentialType(self.electric_potential)
        self.dipole_correction = dipole_correction
        self.gate_settings = gate_settings
        self.electric_field_direction = electric_field_direction
        self.potential_max_position = potential_max_position
        self.potential_decrease_width = potential_decrease_width
        self.electric_field_amplitude = electric_field_amplitude
        self.electric_field_vector = electric_field_vector
        self.validate_d3vectorType(self.electric_field_vector)
        self.nk_per_string = nk_per_string
        self.n_berry_cycles = n_berry_cycles
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, electric_fieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if electric_fieldType.subclass:
            return electric_fieldType.subclass(*args_, **kwargs_)
        else:
            return electric_fieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_electric_potential(self): return self.electric_potential
    def set_electric_potential(self, electric_potential): self.electric_potential = electric_potential
    def get_dipole_correction(self): return self.dipole_correction
    def set_dipole_correction(self, dipole_correction): self.dipole_correction = dipole_correction
    def get_gate_settings(self): return self.gate_settings
    def set_gate_settings(self, gate_settings): self.gate_settings = gate_settings
    def get_electric_field_direction(self): return self.electric_field_direction
    def set_electric_field_direction(self, electric_field_direction): self.electric_field_direction = electric_field_direction
    def get_potential_max_position(self): return self.potential_max_position
    def set_potential_max_position(self, potential_max_position): self.potential_max_position = potential_max_position
    def get_potential_decrease_width(self): return self.potential_decrease_width
    def set_potential_decrease_width(self, potential_decrease_width): self.potential_decrease_width = potential_decrease_width
    def get_electric_field_amplitude(self): return self.electric_field_amplitude
    def set_electric_field_amplitude(self, electric_field_amplitude): self.electric_field_amplitude = electric_field_amplitude
    def get_electric_field_vector(self): return self.electric_field_vector
    def set_electric_field_vector(self, electric_field_vector): self.electric_field_vector = electric_field_vector
    def get_nk_per_string(self): return self.nk_per_string
    def set_nk_per_string(self, nk_per_string): self.nk_per_string = nk_per_string
    def get_n_berry_cycles(self): return self.n_berry_cycles
    def set_n_berry_cycles(self, n_berry_cycles): self.n_berry_cycles = n_berry_cycles
    def validate_electric_potentialType(self, value):
        # Validate type electric_potentialType, a restriction on string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['sawtooth_potential', 'homogenous_field', 'Berry_Phase', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on electric_potentialType' % {"value" : value.encode("utf-8")} )
    def validate_d3vectorType(self, value):
        # Validate type d3vectorType, a restriction on double.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on d3vectorType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.electric_potential is not None or
            self.dipole_correction or
            self.gate_settings is not None or
            self.electric_field_direction is not None or
            self.potential_max_position is not None or
            self.potential_decrease_width is not None or
            self.electric_field_amplitude is not None or
            self.electric_field_vector is not None or
            self.nk_per_string is not None or
            self.n_berry_cycles is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='electric_fieldType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('electric_fieldType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='electric_fieldType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='electric_fieldType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='electric_fieldType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='electric_fieldType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.electric_potential is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:electric_potential>%s</qes:electric_potential>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.electric_potential), input_name='electric_potential')), eol_))
        if self.dipole_correction:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:dipole_correction>%s</qes:dipole_correction>%s' % (self.gds_format_boolean(self.dipole_correction, input_name='dipole_correction'), eol_))
        if self.gate_settings is not None:
            self.gate_settings.export(outfile, level, namespaceprefix_, name_='gate_settings', pretty_print=pretty_print)
        if self.electric_field_direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:electric_field_direction>%s</qes:electric_field_direction>%s' % (self.gds_format_integer(self.electric_field_direction, input_name='electric_field_direction'), eol_))
        if self.potential_max_position is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:potential_max_position>%s</qes:potential_max_position>%s' % (self.gds_format_double(self.potential_max_position, input_name='potential_max_position'), eol_))
        if self.potential_decrease_width is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:potential_decrease_width>%s</qes:potential_decrease_width>%s' % (self.gds_format_double(self.potential_decrease_width, input_name='potential_decrease_width'), eol_))
        if self.electric_field_amplitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:electric_field_amplitude>%s</qes:electric_field_amplitude>%s' % (self.gds_format_double(self.electric_field_amplitude, input_name='electric_field_amplitude'), eol_))
        if self.electric_field_vector is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:electric_field_vector>%s</qes:electric_field_vector>%s' % (self.gds_format_double_list(self.electric_field_vector, input_name='electric_field_vector'), eol_))
        if self.nk_per_string is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nk_per_string>%s</qes:nk_per_string>%s' % (self.gds_format_integer(self.nk_per_string, input_name='nk_per_string'), eol_))
        if self.n_berry_cycles is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:n_berry_cycles>%s</qes:n_berry_cycles>%s' % (self.gds_format_integer(self.n_berry_cycles, input_name='n_berry_cycles'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'electric_potential':
            electric_potential_ = child_.text
            electric_potential_ = self.gds_validate_string(electric_potential_, node, 'electric_potential')
            self.electric_potential = electric_potential_
            # validate type electric_potentialType
            self.validate_electric_potentialType(self.electric_potential)
        elif nodeName_ == 'dipole_correction':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'dipole_correction')
            self.dipole_correction = ival_
        elif nodeName_ == 'gate_settings':
            obj_ = gate_settingsType.factory()
            obj_.build(child_)
            self.gate_settings = obj_
            obj_.original_tagname_ = 'gate_settings'
        elif nodeName_ == 'electric_field_direction' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'electric_field_direction')
            self.electric_field_direction = ival_
        elif nodeName_ == 'potential_max_position' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'potential_max_position')
            self.potential_max_position = fval_
        elif nodeName_ == 'potential_decrease_width' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'potential_decrease_width')
            self.potential_decrease_width = fval_
        elif nodeName_ == 'electric_field_amplitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'electric_field_amplitude')
            self.electric_field_amplitude = fval_
        elif nodeName_ == 'electric_field_vector':
            electric_field_vector_ = child_.text
            electric_field_vector_ = self.gds_validate_double_list(electric_field_vector_, node, 'electric_field_vector')
            self.electric_field_vector = electric_field_vector_
            # validate type d3vectorType
            self.validate_d3vectorType(self.electric_field_vector)
        elif nodeName_ == 'nk_per_string' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'nk_per_string')
            self.nk_per_string = ival_
        elif nodeName_ == 'n_berry_cycles' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'n_berry_cycles')
            self.n_berry_cycles = ival_
# end class electric_fieldType


class gate_settingsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, use_gate=None, zgate=None, relaxz=None, block=None, block_1=None, block_2=None, block_height=None):
        self.original_tagname_ = None
        self.use_gate = use_gate
        self.zgate = zgate
        self.relaxz = relaxz
        self.block = block
        self.block_1 = block_1
        self.block_2 = block_2
        self.block_height = block_height
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gate_settingsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gate_settingsType.subclass:
            return gate_settingsType.subclass(*args_, **kwargs_)
        else:
            return gate_settingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_use_gate(self): return self.use_gate
    def set_use_gate(self, use_gate): self.use_gate = use_gate
    def get_zgate(self): return self.zgate
    def set_zgate(self, zgate): self.zgate = zgate
    def get_relaxz(self): return self.relaxz
    def set_relaxz(self, relaxz): self.relaxz = relaxz
    def get_block(self): return self.block
    def set_block(self, block): self.block = block
    def get_block_1(self): return self.block_1
    def set_block_1(self, block_1): self.block_1 = block_1
    def get_block_2(self): return self.block_2
    def set_block_2(self, block_2): self.block_2 = block_2
    def get_block_height(self): return self.block_height
    def set_block_height(self, block_height): self.block_height = block_height
    def hasContent_(self):
        if (
            self.use_gate is not None or
            self.zgate is not None or
            self.relaxz is not None or
            self.block is not None or
            self.block_1 is not None or
            self.block_2 is not None or
            self.block_height is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='gate_settingsType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gate_settingsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gate_settingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='gate_settingsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='gate_settingsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='gate_settingsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.use_gate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:use_gate>%s</qes:use_gate>%s' % (self.gds_format_boolean(self.use_gate, input_name='use_gate'), eol_))
        if self.zgate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:zgate>%s</qes:zgate>%s' % (self.gds_format_double(self.zgate, input_name='zgate'), eol_))
        if self.relaxz is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:relaxz>%s</qes:relaxz>%s' % (self.gds_format_boolean(self.relaxz, input_name='relaxz'), eol_))
        if self.block is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:block>%s</qes:block>%s' % (self.gds_format_boolean(self.block, input_name='block'), eol_))
        if self.block_1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:block_1>%s</qes:block_1>%s' % (self.gds_format_double(self.block_1, input_name='block_1'), eol_))
        if self.block_2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:block_2>%s</qes:block_2>%s' % (self.gds_format_double(self.block_2, input_name='block_2'), eol_))
        if self.block_height is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:block_height>%s</qes:block_height>%s' % (self.gds_format_double(self.block_height, input_name='block_height'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'use_gate':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'use_gate')
            self.use_gate = ival_
        elif nodeName_ == 'zgate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'zgate')
            self.zgate = fval_
        elif nodeName_ == 'relaxz':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'relaxz')
            self.relaxz = ival_
        elif nodeName_ == 'block':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'block')
            self.block = ival_
        elif nodeName_ == 'block_1' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'block_1')
            self.block_1 = fval_
        elif nodeName_ == 'block_2' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'block_2')
            self.block_2 = fval_
        elif nodeName_ == 'block_height' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'block_height')
            self.block_height = fval_
# end class gate_settingsType


class atomic_constraintsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, num_of_constraints=None, tolerance=None, atomic_constraint=None):
        self.original_tagname_ = None
        self.num_of_constraints = num_of_constraints
        self.tolerance = tolerance
        if atomic_constraint is None:
            self.atomic_constraint = []
        else:
            self.atomic_constraint = atomic_constraint
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, atomic_constraintsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if atomic_constraintsType.subclass:
            return atomic_constraintsType.subclass(*args_, **kwargs_)
        else:
            return atomic_constraintsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_num_of_constraints(self): return self.num_of_constraints
    def set_num_of_constraints(self, num_of_constraints): self.num_of_constraints = num_of_constraints
    def get_tolerance(self): return self.tolerance
    def set_tolerance(self, tolerance): self.tolerance = tolerance
    def get_atomic_constraint(self): return self.atomic_constraint
    def set_atomic_constraint(self, atomic_constraint): self.atomic_constraint = atomic_constraint
    def add_atomic_constraint(self, value): self.atomic_constraint.append(value)
    def insert_atomic_constraint_at(self, index, value): self.atomic_constraint.insert(index, value)
    def replace_atomic_constraint_at(self, index, value): self.atomic_constraint[index] = value
    def hasContent_(self):
        if (
            self.num_of_constraints is not None or
            self.tolerance is not None or
            self.atomic_constraint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='atomic_constraintsType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('atomic_constraintsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='atomic_constraintsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='atomic_constraintsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='atomic_constraintsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='atomic_constraintsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.num_of_constraints is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:num_of_constraints>%s</qes:num_of_constraints>%s' % (self.gds_format_integer(self.num_of_constraints, input_name='num_of_constraints'), eol_))
        if self.tolerance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:tolerance>%s</qes:tolerance>%s' % (self.gds_format_double(self.tolerance, input_name='tolerance'), eol_))
        for atomic_constraint_ in self.atomic_constraint:
            atomic_constraint_.export(outfile, level, namespaceprefix_, name_='atomic_constraint', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'num_of_constraints' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'num_of_constraints')
            self.num_of_constraints = ival_
        elif nodeName_ == 'tolerance' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'tolerance')
            self.tolerance = fval_
        elif nodeName_ == 'atomic_constraint':
            obj_ = atomic_constraintType.factory()
            obj_.build(child_)
            self.atomic_constraint.append(obj_)
            obj_.original_tagname_ = 'atomic_constraint'
# end class atomic_constraintsType


class atomic_constraintType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, constr_parms=None, constr_type=None, constr_target=None):
        self.original_tagname_ = None
        self.constr_parms = constr_parms
        self.validate_constr_parms_listType(self.constr_parms)
        self.constr_type = constr_type
        self.validate_constr_typeType(self.constr_type)
        self.constr_target = constr_target
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, atomic_constraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if atomic_constraintType.subclass:
            return atomic_constraintType.subclass(*args_, **kwargs_)
        else:
            return atomic_constraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constr_parms(self): return self.constr_parms
    def set_constr_parms(self, constr_parms): self.constr_parms = constr_parms
    def get_constr_type(self): return self.constr_type
    def set_constr_type(self, constr_type): self.constr_type = constr_type
    def get_constr_target(self): return self.constr_target
    def set_constr_target(self, constr_target): self.constr_target = constr_target
    def validate_constr_parms_listType(self, value):
        # Validate type constr_parms_listType, a restriction on double.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 4:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on constr_parms_listType' % {"value" : value} )
    def validate_constr_typeType(self, value):
        # Validate type constr_typeType, a restriction on string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['type_coord', 'atom_coord', 'distance', 'planar_angle', 'torsional_angle', 'bennet_proj']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on constr_typeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.constr_parms is not None or
            self.constr_type is not None or
            self.constr_target is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='atomic_constraintType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('atomic_constraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='atomic_constraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='atomic_constraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='atomic_constraintType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='atomic_constraintType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.constr_parms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:constr_parms>%s</qes:constr_parms>%s' % (self.gds_format_double_list(self.constr_parms, input_name='constr_parms'), eol_))
        if self.constr_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:constr_type>%s</qes:constr_type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.constr_type), input_name='constr_type')), eol_))
        if self.constr_target is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:constr_target>%s</qes:constr_target>%s' % (self.gds_format_double(self.constr_target, input_name='constr_target'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'constr_parms':
            constr_parms_ = child_.text
            constr_parms_ = self.gds_validate_double_list(constr_parms_, node, 'constr_parms')
            self.constr_parms = constr_parms_
            # validate type constr_parms_listType
            self.validate_constr_parms_listType(self.constr_parms)
        elif nodeName_ == 'constr_type':
            constr_type_ = child_.text
            constr_type_ = self.gds_validate_string(constr_type_, node, 'constr_type')
            self.constr_type = constr_type_
            # validate type constr_typeType
            self.validate_constr_typeType(self.constr_type)
        elif nodeName_ == 'constr_target' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'constr_target')
            self.constr_target = fval_
# end class atomic_constraintType


class outputElectricFieldType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BerryPhase=None, finiteElectricFieldInfo=None, dipoleInfo=None, gateInfo=None):
        self.original_tagname_ = None
        self.BerryPhase = BerryPhase
        self.finiteElectricFieldInfo = finiteElectricFieldInfo
        self.dipoleInfo = dipoleInfo
        self.gateInfo = gateInfo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, outputElectricFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if outputElectricFieldType.subclass:
            return outputElectricFieldType.subclass(*args_, **kwargs_)
        else:
            return outputElectricFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BerryPhase(self): return self.BerryPhase
    def set_BerryPhase(self, BerryPhase): self.BerryPhase = BerryPhase
    def get_finiteElectricFieldInfo(self): return self.finiteElectricFieldInfo
    def set_finiteElectricFieldInfo(self, finiteElectricFieldInfo): self.finiteElectricFieldInfo = finiteElectricFieldInfo
    def get_dipoleInfo(self): return self.dipoleInfo
    def set_dipoleInfo(self, dipoleInfo): self.dipoleInfo = dipoleInfo
    def get_gateInfo(self): return self.gateInfo
    def set_gateInfo(self, gateInfo): self.gateInfo = gateInfo
    def hasContent_(self):
        if (
            self.BerryPhase is not None or
            self.finiteElectricFieldInfo is not None or
            self.dipoleInfo is not None or
            self.gateInfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='outputElectricFieldType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('outputElectricFieldType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='outputElectricFieldType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='outputElectricFieldType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='outputElectricFieldType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='outputElectricFieldType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BerryPhase is not None:
            self.BerryPhase.export(outfile, level, namespaceprefix_, name_='BerryPhase', pretty_print=pretty_print)
        if self.finiteElectricFieldInfo is not None:
            self.finiteElectricFieldInfo.export(outfile, level, namespaceprefix_, name_='finiteElectricFieldInfo', pretty_print=pretty_print)
        if self.dipoleInfo is not None:
            self.dipoleInfo.export(outfile, level, namespaceprefix_, name_='dipoleInfo', pretty_print=pretty_print)
        if self.gateInfo is not None:
            self.gateInfo.export(outfile, level, namespaceprefix_, name_='gateInfo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BerryPhase':
            obj_ = BerryPhaseOutputType.factory()
            obj_.build(child_)
            self.BerryPhase = obj_
            obj_.original_tagname_ = 'BerryPhase'
        elif nodeName_ == 'finiteElectricFieldInfo':
            obj_ = finiteFieldOutType.factory()
            obj_.build(child_)
            self.finiteElectricFieldInfo = obj_
            obj_.original_tagname_ = 'finiteElectricFieldInfo'
        elif nodeName_ == 'dipoleInfo':
            obj_ = dipoleOutputType.factory()
            obj_.build(child_)
            self.dipoleInfo = obj_
            obj_.original_tagname_ = 'dipoleInfo'
        elif nodeName_ == 'gateInfo':
            obj_ = gateInfoType.factory()
            obj_.build(child_)
            self.gateInfo = obj_
            obj_.original_tagname_ = 'gateInfo'
# end class outputElectricFieldType


class BerryPhaseOutputType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, totalPolarization=None, totalPhase=None, ionicPolarization=None, electronicPolarization=None):
        self.original_tagname_ = None
        self.totalPolarization = totalPolarization
        self.totalPhase = totalPhase
        if ionicPolarization is None:
            self.ionicPolarization = []
        else:
            self.ionicPolarization = ionicPolarization
        if electronicPolarization is None:
            self.electronicPolarization = []
        else:
            self.electronicPolarization = electronicPolarization
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BerryPhaseOutputType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BerryPhaseOutputType.subclass:
            return BerryPhaseOutputType.subclass(*args_, **kwargs_)
        else:
            return BerryPhaseOutputType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_totalPolarization(self): return self.totalPolarization
    def set_totalPolarization(self, totalPolarization): self.totalPolarization = totalPolarization
    def get_totalPhase(self): return self.totalPhase
    def set_totalPhase(self, totalPhase): self.totalPhase = totalPhase
    def get_ionicPolarization(self): return self.ionicPolarization
    def set_ionicPolarization(self, ionicPolarization): self.ionicPolarization = ionicPolarization
    def add_ionicPolarization(self, value): self.ionicPolarization.append(value)
    def insert_ionicPolarization_at(self, index, value): self.ionicPolarization.insert(index, value)
    def replace_ionicPolarization_at(self, index, value): self.ionicPolarization[index] = value
    def get_electronicPolarization(self): return self.electronicPolarization
    def set_electronicPolarization(self, electronicPolarization): self.electronicPolarization = electronicPolarization
    def add_electronicPolarization(self, value): self.electronicPolarization.append(value)
    def insert_electronicPolarization_at(self, index, value): self.electronicPolarization.insert(index, value)
    def replace_electronicPolarization_at(self, index, value): self.electronicPolarization[index] = value
    def hasContent_(self):
        if (
            self.totalPolarization is not None or
            self.totalPhase is not None or
            self.ionicPolarization or
            self.electronicPolarization
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='BerryPhaseOutputType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BerryPhaseOutputType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BerryPhaseOutputType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='BerryPhaseOutputType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='BerryPhaseOutputType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='BerryPhaseOutputType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.totalPolarization is not None:
            self.totalPolarization.export(outfile, level, namespaceprefix_, name_='totalPolarization', pretty_print=pretty_print)
        if self.totalPhase is not None:
            self.totalPhase.export(outfile, level, namespaceprefix_, name_='totalPhase', pretty_print=pretty_print)
        for ionicPolarization_ in self.ionicPolarization:
            ionicPolarization_.export(outfile, level, namespaceprefix_, name_='ionicPolarization', pretty_print=pretty_print)
        for electronicPolarization_ in self.electronicPolarization:
            electronicPolarization_.export(outfile, level, namespaceprefix_, name_='electronicPolarization', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'totalPolarization':
            obj_ = polarizationType.factory()
            obj_.build(child_)
            self.totalPolarization = obj_
            obj_.original_tagname_ = 'totalPolarization'
        elif nodeName_ == 'totalPhase':
            obj_ = phaseType.factory()
            obj_.build(child_)
            self.totalPhase = obj_
            obj_.original_tagname_ = 'totalPhase'
        elif nodeName_ == 'ionicPolarization':
            obj_ = ionicPolarizationType.factory()
            obj_.build(child_)
            self.ionicPolarization.append(obj_)
            obj_.original_tagname_ = 'ionicPolarization'
        elif nodeName_ == 'electronicPolarization':
            obj_ = electronicPolarizationType.factory()
            obj_.build(child_)
            self.electronicPolarization.append(obj_)
            obj_.original_tagname_ = 'electronicPolarization'
# end class BerryPhaseOutputType


class dipoleOutputType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, idir=None, dipole=None, ion_dipole=None, elec_dipole=None, dipoleField=None, potentialAmp=None, totalLength=None):
        self.original_tagname_ = None
        self.idir = idir
        self.dipole = dipole
        self.ion_dipole = ion_dipole
        self.elec_dipole = elec_dipole
        self.dipoleField = dipoleField
        self.potentialAmp = potentialAmp
        self.totalLength = totalLength
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dipoleOutputType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dipoleOutputType.subclass:
            return dipoleOutputType.subclass(*args_, **kwargs_)
        else:
            return dipoleOutputType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_idir(self): return self.idir
    def set_idir(self, idir): self.idir = idir
    def get_dipole(self): return self.dipole
    def set_dipole(self, dipole): self.dipole = dipole
    def get_ion_dipole(self): return self.ion_dipole
    def set_ion_dipole(self, ion_dipole): self.ion_dipole = ion_dipole
    def get_elec_dipole(self): return self.elec_dipole
    def set_elec_dipole(self, elec_dipole): self.elec_dipole = elec_dipole
    def get_dipoleField(self): return self.dipoleField
    def set_dipoleField(self, dipoleField): self.dipoleField = dipoleField
    def get_potentialAmp(self): return self.potentialAmp
    def set_potentialAmp(self, potentialAmp): self.potentialAmp = potentialAmp
    def get_totalLength(self): return self.totalLength
    def set_totalLength(self, totalLength): self.totalLength = totalLength
    def hasContent_(self):
        if (
            self.idir is not None or
            self.dipole is not None or
            self.ion_dipole is not None or
            self.elec_dipole is not None or
            self.dipoleField is not None or
            self.potentialAmp is not None or
            self.totalLength is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='dipoleOutputType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dipoleOutputType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dipoleOutputType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='dipoleOutputType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='dipoleOutputType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='dipoleOutputType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.idir is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:idir>%s</qes:idir>%s' % (self.gds_format_integer(self.idir, input_name='idir'), eol_))
        if self.dipole is not None:
            self.dipole.export(outfile, level, namespaceprefix_, name_='dipole', pretty_print=pretty_print)
        if self.ion_dipole is not None:
            self.ion_dipole.export(outfile, level, namespaceprefix_, name_='ion_dipole', pretty_print=pretty_print)
        if self.elec_dipole is not None:
            self.elec_dipole.export(outfile, level, namespaceprefix_, name_='elec_dipole', pretty_print=pretty_print)
        if self.dipoleField is not None:
            self.dipoleField.export(outfile, level, namespaceprefix_, name_='dipoleField', pretty_print=pretty_print)
        if self.potentialAmp is not None:
            self.potentialAmp.export(outfile, level, namespaceprefix_, name_='potentialAmp', pretty_print=pretty_print)
        if self.totalLength is not None:
            self.totalLength.export(outfile, level, namespaceprefix_, name_='totalLength', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'idir' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'idir')
            self.idir = ival_
        elif nodeName_ == 'dipole':
            obj_ = scalarQuantityType.factory()
            obj_.build(child_)
            self.dipole = obj_
            obj_.original_tagname_ = 'dipole'
        elif nodeName_ == 'ion_dipole':
            obj_ = scalarQuantityType.factory()
            obj_.build(child_)
            self.ion_dipole = obj_
            obj_.original_tagname_ = 'ion_dipole'
        elif nodeName_ == 'elec_dipole':
            obj_ = scalarQuantityType.factory()
            obj_.build(child_)
            self.elec_dipole = obj_
            obj_.original_tagname_ = 'elec_dipole'
        elif nodeName_ == 'dipoleField':
            obj_ = scalarQuantityType.factory()
            obj_.build(child_)
            self.dipoleField = obj_
            obj_.original_tagname_ = 'dipoleField'
        elif nodeName_ == 'potentialAmp':
            obj_ = scalarQuantityType.factory()
            obj_.build(child_)
            self.potentialAmp = obj_
            obj_.original_tagname_ = 'potentialAmp'
        elif nodeName_ == 'totalLength':
            obj_ = scalarQuantityType.factory()
            obj_.build(child_)
            self.totalLength = obj_
            obj_.original_tagname_ = 'totalLength'
# end class dipoleOutputType


class finiteFieldOutType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, electronicDipole=None, ionicDipole=None):
        self.original_tagname_ = None
        self.electronicDipole = electronicDipole
        self.validate_d3vectorType(self.electronicDipole)
        self.ionicDipole = ionicDipole
        self.validate_d3vectorType(self.ionicDipole)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, finiteFieldOutType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if finiteFieldOutType.subclass:
            return finiteFieldOutType.subclass(*args_, **kwargs_)
        else:
            return finiteFieldOutType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_electronicDipole(self): return self.electronicDipole
    def set_electronicDipole(self, electronicDipole): self.electronicDipole = electronicDipole
    def get_ionicDipole(self): return self.ionicDipole
    def set_ionicDipole(self, ionicDipole): self.ionicDipole = ionicDipole
    def validate_d3vectorType(self, value):
        # Validate type d3vectorType, a restriction on double.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on d3vectorType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.electronicDipole is not None or
            self.ionicDipole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='finiteFieldOutType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('finiteFieldOutType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='finiteFieldOutType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='finiteFieldOutType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='finiteFieldOutType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='finiteFieldOutType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.electronicDipole is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:electronicDipole>%s</qes:electronicDipole>%s' % (self.gds_format_double_list(self.electronicDipole, input_name='electronicDipole'), eol_))
        if self.ionicDipole is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ionicDipole>%s</qes:ionicDipole>%s' % (self.gds_format_double_list(self.ionicDipole, input_name='ionicDipole'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'electronicDipole':
            electronicDipole_ = child_.text
            electronicDipole_ = self.gds_validate_double_list(electronicDipole_, node, 'electronicDipole')
            self.electronicDipole = electronicDipole_
            # validate type d3vectorType
            self.validate_d3vectorType(self.electronicDipole)
        elif nodeName_ == 'ionicDipole':
            ionicDipole_ = child_.text
            ionicDipole_ = self.gds_validate_double_list(ionicDipole_, node, 'ionicDipole')
            self.ionicDipole = ionicDipole_
            # validate type d3vectorType
            self.validate_d3vectorType(self.ionicDipole)
# end class finiteFieldOutType


class polarizationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, polarization=None, modulus=None, direction=None):
        self.original_tagname_ = None
        self.polarization = polarization
        self.modulus = modulus
        self.direction = direction
        self.validate_d3vectorType(self.direction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, polarizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if polarizationType.subclass:
            return polarizationType.subclass(*args_, **kwargs_)
        else:
            return polarizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_polarization(self): return self.polarization
    def set_polarization(self, polarization): self.polarization = polarization
    def get_modulus(self): return self.modulus
    def set_modulus(self, modulus): self.modulus = modulus
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def validate_d3vectorType(self, value):
        # Validate type d3vectorType, a restriction on double.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on d3vectorType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.polarization is not None or
            self.modulus is not None or
            self.direction is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='polarizationType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('polarizationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='polarizationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='polarizationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='polarizationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='polarizationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.polarization is not None:
            self.polarization.export(outfile, level, namespaceprefix_, name_='polarization', pretty_print=pretty_print)
        if self.modulus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:modulus>%s</qes:modulus>%s' % (self.gds_format_double(self.modulus, input_name='modulus'), eol_))
        if self.direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:direction>%s</qes:direction>%s' % (self.gds_format_double_list(self.direction, input_name='direction'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polarization':
            obj_ = scalarQuantityType.factory()
            obj_.build(child_)
            self.polarization = obj_
            obj_.original_tagname_ = 'polarization'
        elif nodeName_ == 'modulus' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'modulus')
            self.modulus = fval_
        elif nodeName_ == 'direction':
            direction_ = child_.text
            direction_ = self.gds_validate_double_list(direction_, node, 'direction')
            self.direction = direction_
            # validate type d3vectorType
            self.validate_d3vectorType(self.direction)
# end class polarizationType


class ionicPolarizationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ion=None, charge=None, phase=None):
        self.original_tagname_ = None
        self.ion = ion
        self.charge = charge
        self.phase = phase
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ionicPolarizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ionicPolarizationType.subclass:
            return ionicPolarizationType.subclass(*args_, **kwargs_)
        else:
            return ionicPolarizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ion(self): return self.ion
    def set_ion(self, ion): self.ion = ion
    def get_charge(self): return self.charge
    def set_charge(self, charge): self.charge = charge
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def hasContent_(self):
        if (
            self.ion is not None or
            self.charge is not None or
            self.phase is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='ionicPolarizationType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ionicPolarizationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ionicPolarizationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='ionicPolarizationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='ionicPolarizationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='ionicPolarizationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ion is not None:
            self.ion.export(outfile, level, namespaceprefix_, name_='ion', pretty_print=pretty_print)
        if self.charge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:charge>%s</qes:charge>%s' % (self.gds_format_double(self.charge, input_name='charge'), eol_))
        if self.phase is not None:
            self.phase.export(outfile, level, namespaceprefix_, name_='phase', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ion':
            obj_ = atomType.factory()
            obj_.build(child_)
            self.ion = obj_
            obj_.original_tagname_ = 'ion'
        elif nodeName_ == 'charge' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'charge')
            self.charge = fval_
        elif nodeName_ == 'phase':
            obj_ = phaseType.factory()
            obj_.build(child_)
            self.phase = obj_
            obj_.original_tagname_ = 'phase'
# end class ionicPolarizationType


class electronicPolarizationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, firstKeyPoint=None, spin=None, phase=None):
        self.original_tagname_ = None
        self.firstKeyPoint = firstKeyPoint
        self.spin = spin
        self.phase = phase
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, electronicPolarizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if electronicPolarizationType.subclass:
            return electronicPolarizationType.subclass(*args_, **kwargs_)
        else:
            return electronicPolarizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_firstKeyPoint(self): return self.firstKeyPoint
    def set_firstKeyPoint(self, firstKeyPoint): self.firstKeyPoint = firstKeyPoint
    def get_spin(self): return self.spin
    def set_spin(self, spin): self.spin = spin
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def hasContent_(self):
        if (
            self.firstKeyPoint is not None or
            self.spin is not None or
            self.phase is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='electronicPolarizationType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('electronicPolarizationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='electronicPolarizationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='electronicPolarizationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='electronicPolarizationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='electronicPolarizationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.firstKeyPoint is not None:
            self.firstKeyPoint.export(outfile, level, namespaceprefix_, name_='firstKeyPoint', pretty_print=pretty_print)
        if self.spin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:spin>%s</qes:spin>%s' % (self.gds_format_integer(self.spin, input_name='spin'), eol_))
        if self.phase is not None:
            self.phase.export(outfile, level, namespaceprefix_, name_='phase', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'firstKeyPoint':
            obj_ = k_pointType.factory()
            obj_.build(child_)
            self.firstKeyPoint = obj_
            obj_.original_tagname_ = 'firstKeyPoint'
        elif nodeName_ == 'spin' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'spin')
            self.spin = ival_
        elif nodeName_ == 'phase':
            obj_ = phaseType.factory()
            obj_.build(child_)
            self.phase = obj_
            obj_.original_tagname_ = 'phase'
# end class electronicPolarizationType


class phaseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ionic=None, electronic=None, modulus=None, valueOf_=None):
        self.original_tagname_ = None
        self.ionic = _cast(float, ionic)
        self.electronic = _cast(float, electronic)
        self.modulus = _cast(None, modulus)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, phaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if phaseType.subclass:
            return phaseType.subclass(*args_, **kwargs_)
        else:
            return phaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ionic(self): return self.ionic
    def set_ionic(self, ionic): self.ionic = ionic
    def get_electronic(self): return self.electronic
    def set_electronic(self, electronic): self.electronic = electronic
    def get_modulus(self): return self.modulus
    def set_modulus(self, modulus): self.modulus = modulus
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='phaseType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('phaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='phaseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='phaseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='phaseType'):
        if self.ionic is not None and 'ionic' not in already_processed:
            already_processed.add('ionic')
            outfile.write(' ionic="%s"' % self.gds_format_double(self.ionic, input_name='ionic'))
        if self.electronic is not None and 'electronic' not in already_processed:
            already_processed.add('electronic')
            outfile.write(' electronic="%s"' % self.gds_format_double(self.electronic, input_name='electronic'))
        if self.modulus is not None and 'modulus' not in already_processed:
            already_processed.add('modulus')
            outfile.write(' modulus=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modulus), input_name='modulus')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='phaseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ionic', node)
        if value is not None and 'ionic' not in already_processed:
            already_processed.add('ionic')
            try:
                self.ionic = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ionic): %s' % exp)
        value = find_attr_value_('electronic', node)
        if value is not None and 'electronic' not in already_processed:
            already_processed.add('electronic')
            try:
                self.electronic = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (electronic): %s' % exp)
        value = find_attr_value_('modulus', node)
        if value is not None and 'modulus' not in already_processed:
            already_processed.add('modulus')
            self.modulus = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class phaseType


class gateInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pot_prefactor=None, gate_zpos=None, gate_gate_term=None, gatefieldEnergy=None):
        self.original_tagname_ = None
        self.pot_prefactor = pot_prefactor
        self.gate_zpos = gate_zpos
        self.gate_gate_term = gate_gate_term
        self.gatefieldEnergy = gatefieldEnergy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gateInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gateInfoType.subclass:
            return gateInfoType.subclass(*args_, **kwargs_)
        else:
            return gateInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pot_prefactor(self): return self.pot_prefactor
    def set_pot_prefactor(self, pot_prefactor): self.pot_prefactor = pot_prefactor
    def get_gate_zpos(self): return self.gate_zpos
    def set_gate_zpos(self, gate_zpos): self.gate_zpos = gate_zpos
    def get_gate_gate_term(self): return self.gate_gate_term
    def set_gate_gate_term(self, gate_gate_term): self.gate_gate_term = gate_gate_term
    def get_gatefieldEnergy(self): return self.gatefieldEnergy
    def set_gatefieldEnergy(self, gatefieldEnergy): self.gatefieldEnergy = gatefieldEnergy
    def hasContent_(self):
        if (
            self.pot_prefactor is not None or
            self.gate_zpos is not None or
            self.gate_gate_term is not None or
            self.gatefieldEnergy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='gateInfoType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gateInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gateInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='gateInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='gateInfoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='gateInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pot_prefactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:pot_prefactor>%s</qes:pot_prefactor>%s' % (self.gds_format_double(self.pot_prefactor, input_name='pot_prefactor'), eol_))
        if self.gate_zpos is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:gate_zpos>%s</qes:gate_zpos>%s' % (self.gds_format_double(self.gate_zpos, input_name='gate_zpos'), eol_))
        if self.gate_gate_term is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:gate_gate_term>%s</qes:gate_gate_term>%s' % (self.gds_format_double(self.gate_gate_term, input_name='gate_gate_term'), eol_))
        if self.gatefieldEnergy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:gatefieldEnergy>%s</qes:gatefieldEnergy>%s' % (self.gds_format_double(self.gatefieldEnergy, input_name='gatefieldEnergy'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pot_prefactor' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'pot_prefactor')
            self.pot_prefactor = fval_
        elif nodeName_ == 'gate_zpos' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'gate_zpos')
            self.gate_zpos = fval_
        elif nodeName_ == 'gate_gate_term' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'gate_gate_term')
            self.gate_gate_term = fval_
        elif nodeName_ == 'gatefieldEnergy' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'gatefieldEnergy')
            self.gatefieldEnergy = fval_
# end class gateInfoType


class convergence_infoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scf_conv=None, opt_conv=None):
        self.original_tagname_ = None
        self.scf_conv = scf_conv
        self.opt_conv = opt_conv
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, convergence_infoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if convergence_infoType.subclass:
            return convergence_infoType.subclass(*args_, **kwargs_)
        else:
            return convergence_infoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scf_conv(self): return self.scf_conv
    def set_scf_conv(self, scf_conv): self.scf_conv = scf_conv
    def get_opt_conv(self): return self.opt_conv
    def set_opt_conv(self, opt_conv): self.opt_conv = opt_conv
    def hasContent_(self):
        if (
            self.scf_conv is not None or
            self.opt_conv is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='convergence_infoType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('convergence_infoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='convergence_infoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='convergence_infoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='convergence_infoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='convergence_infoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.scf_conv is not None:
            self.scf_conv.export(outfile, level, namespaceprefix_, name_='scf_conv', pretty_print=pretty_print)
        if self.opt_conv is not None:
            self.opt_conv.export(outfile, level, namespaceprefix_, name_='opt_conv', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scf_conv':
            obj_ = scf_convType.factory()
            obj_.build(child_)
            self.scf_conv = obj_
            obj_.original_tagname_ = 'scf_conv'
        elif nodeName_ == 'opt_conv':
            obj_ = opt_convType.factory()
            obj_.build(child_)
            self.opt_conv = obj_
            obj_.original_tagname_ = 'opt_conv'
# end class convergence_infoType


class scf_convType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, n_scf_steps=None, scf_error=None):
        self.original_tagname_ = None
        self.n_scf_steps = n_scf_steps
        self.scf_error = scf_error
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scf_convType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scf_convType.subclass:
            return scf_convType.subclass(*args_, **kwargs_)
        else:
            return scf_convType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_n_scf_steps(self): return self.n_scf_steps
    def set_n_scf_steps(self, n_scf_steps): self.n_scf_steps = n_scf_steps
    def get_scf_error(self): return self.scf_error
    def set_scf_error(self, scf_error): self.scf_error = scf_error
    def hasContent_(self):
        if (
            self.n_scf_steps is not None or
            self.scf_error is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='scf_convType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scf_convType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scf_convType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='scf_convType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='scf_convType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='scf_convType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.n_scf_steps is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:n_scf_steps>%s</qes:n_scf_steps>%s' % (self.gds_format_integer(self.n_scf_steps, input_name='n_scf_steps'), eol_))
        if self.scf_error is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:scf_error>%s</qes:scf_error>%s' % (self.gds_format_double(self.scf_error, input_name='scf_error'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'n_scf_steps' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'n_scf_steps')
            self.n_scf_steps = ival_
        elif nodeName_ == 'scf_error' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'scf_error')
            self.scf_error = fval_
# end class scf_convType


class opt_convType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, n_opt_steps=None, grad_norm=None):
        self.original_tagname_ = None
        self.n_opt_steps = n_opt_steps
        self.grad_norm = grad_norm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, opt_convType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if opt_convType.subclass:
            return opt_convType.subclass(*args_, **kwargs_)
        else:
            return opt_convType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_n_opt_steps(self): return self.n_opt_steps
    def set_n_opt_steps(self, n_opt_steps): self.n_opt_steps = n_opt_steps
    def get_grad_norm(self): return self.grad_norm
    def set_grad_norm(self, grad_norm): self.grad_norm = grad_norm
    def hasContent_(self):
        if (
            self.n_opt_steps is not None or
            self.grad_norm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='opt_convType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('opt_convType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='opt_convType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='opt_convType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='opt_convType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='opt_convType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.n_opt_steps is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:n_opt_steps>%s</qes:n_opt_steps>%s' % (self.gds_format_integer(self.n_opt_steps, input_name='n_opt_steps'), eol_))
        if self.grad_norm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:grad_norm>%s</qes:grad_norm>%s' % (self.gds_format_double(self.grad_norm, input_name='grad_norm'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'n_opt_steps' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'n_opt_steps')
            self.n_opt_steps = ival_
        elif nodeName_ == 'grad_norm' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'grad_norm')
            self.grad_norm = fval_
# end class opt_convType


class algorithmic_infoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, real_space_q=None, uspp=None, paw=None):
        self.original_tagname_ = None
        self.real_space_q = real_space_q
        self.uspp = uspp
        self.paw = paw
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, algorithmic_infoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if algorithmic_infoType.subclass:
            return algorithmic_infoType.subclass(*args_, **kwargs_)
        else:
            return algorithmic_infoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_real_space_q(self): return self.real_space_q
    def set_real_space_q(self, real_space_q): self.real_space_q = real_space_q
    def get_uspp(self): return self.uspp
    def set_uspp(self, uspp): self.uspp = uspp
    def get_paw(self): return self.paw
    def set_paw(self, paw): self.paw = paw
    def hasContent_(self):
        if (
            self.real_space_q is not None or
            self.uspp is not None or
            self.paw is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='algorithmic_infoType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('algorithmic_infoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='algorithmic_infoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='algorithmic_infoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='algorithmic_infoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='algorithmic_infoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.real_space_q is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:real_space_q>%s</qes:real_space_q>%s' % (self.gds_format_boolean(self.real_space_q, input_name='real_space_q'), eol_))
        if self.uspp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:uspp>%s</qes:uspp>%s' % (self.gds_format_boolean(self.uspp, input_name='uspp'), eol_))
        if self.paw is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:paw>%s</qes:paw>%s' % (self.gds_format_boolean(self.paw, input_name='paw'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'real_space_q':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'real_space_q')
            self.real_space_q = ival_
        elif nodeName_ == 'uspp':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'uspp')
            self.uspp = ival_
        elif nodeName_ == 'paw':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'paw')
            self.paw = ival_
# end class algorithmic_infoType


class symmetriesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nsym=None, nrot=None, space_group=None, symmetry=None):
        self.original_tagname_ = None
        self.nsym = nsym
        self.nrot = nrot
        self.space_group = space_group
        if symmetry is None:
            self.symmetry = []
        else:
            self.symmetry = symmetry
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, symmetriesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if symmetriesType.subclass:
            return symmetriesType.subclass(*args_, **kwargs_)
        else:
            return symmetriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nsym(self): return self.nsym
    def set_nsym(self, nsym): self.nsym = nsym
    def get_nrot(self): return self.nrot
    def set_nrot(self, nrot): self.nrot = nrot
    def get_space_group(self): return self.space_group
    def set_space_group(self, space_group): self.space_group = space_group
    def get_symmetry(self): return self.symmetry
    def set_symmetry(self, symmetry): self.symmetry = symmetry
    def add_symmetry(self, value): self.symmetry.append(value)
    def insert_symmetry_at(self, index, value): self.symmetry.insert(index, value)
    def replace_symmetry_at(self, index, value): self.symmetry[index] = value
    def hasContent_(self):
        if (
            self.nsym is not None or
            self.nrot is not None or
            self.space_group is not None or
            self.symmetry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='symmetriesType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('symmetriesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='symmetriesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='symmetriesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='symmetriesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='symmetriesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nsym is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nsym>%s</qes:nsym>%s' % (self.gds_format_integer(self.nsym, input_name='nsym'), eol_))
        if self.nrot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nrot>%s</qes:nrot>%s' % (self.gds_format_integer(self.nrot, input_name='nrot'), eol_))
        if self.space_group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:space_group>%s</qes:space_group>%s' % (self.gds_format_integer(self.space_group, input_name='space_group'), eol_))
        for symmetry_ in self.symmetry:
            symmetry_.export(outfile, level, namespaceprefix_, name_='symmetry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nsym' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'nsym')
            self.nsym = ival_
        elif nodeName_ == 'nrot' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'nrot')
            self.nrot = ival_
        elif nodeName_ == 'space_group' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'space_group')
            self.space_group = ival_
        elif nodeName_ == 'symmetry':
            obj_ = symmetryType.factory()
            obj_.build(child_)
            self.symmetry.append(obj_)
            obj_.original_tagname_ = 'symmetry'
# end class symmetriesType


class symmetryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, info=None, rotation=None, fractional_translation=None, equivalent_atoms=None):
        self.original_tagname_ = None
        self.info = info
        self.rotation = rotation
        self.fractional_translation = fractional_translation
        self.validate_d3vectorType(self.fractional_translation)
        self.equivalent_atoms = equivalent_atoms
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, symmetryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if symmetryType.subclass:
            return symmetryType.subclass(*args_, **kwargs_)
        else:
            return symmetryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_info(self): return self.info
    def set_info(self, info): self.info = info
    def get_rotation(self): return self.rotation
    def set_rotation(self, rotation): self.rotation = rotation
    def get_fractional_translation(self): return self.fractional_translation
    def set_fractional_translation(self, fractional_translation): self.fractional_translation = fractional_translation
    def get_equivalent_atoms(self): return self.equivalent_atoms
    def set_equivalent_atoms(self, equivalent_atoms): self.equivalent_atoms = equivalent_atoms
    def validate_d3vectorType(self, value):
        # Validate type d3vectorType, a restriction on double.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on d3vectorType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.info is not None or
            self.rotation is not None or
            self.fractional_translation is not None or
            self.equivalent_atoms is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='symmetryType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('symmetryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='symmetryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='symmetryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='symmetryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='symmetryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.info is not None:
            self.info.export(outfile, level, namespaceprefix_, name_='info', pretty_print=pretty_print)
        if self.rotation is not None:
            self.rotation.export(outfile, level, namespaceprefix_, name_='rotation', pretty_print=pretty_print)
        if self.fractional_translation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:fractional_translation>%s</qes:fractional_translation>%s' % (self.gds_format_double_list(self.fractional_translation, input_name='fractional_translation'), eol_))
        if self.equivalent_atoms is not None:
            self.equivalent_atoms.export(outfile, level, namespaceprefix_, name_='equivalent_atoms', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'info':
            obj_ = infoType.factory()
            obj_.build(child_)
            self.info = obj_
            obj_.original_tagname_ = 'info'
        elif nodeName_ == 'rotation':
            class_obj_ = self.get_class_obj_(child_, matrixType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.rotation = obj_
            obj_.original_tagname_ = 'rotation'
        elif nodeName_ == 'fractional_translation':
            fractional_translation_ = child_.text
            fractional_translation_ = self.gds_validate_double_list(fractional_translation_, node, 'fractional_translation')
            self.fractional_translation = fractional_translation_
            # validate type d3vectorType
            self.validate_d3vectorType(self.fractional_translation)
        elif nodeName_ == 'equivalent_atoms':
            obj_ = equivalent_atomsType.factory()
            obj_.build(child_)
            self.equivalent_atoms = obj_
            obj_.original_tagname_ = 'equivalent_atoms'
# end class symmetryType


class infoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, class_=None, time_reversal=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.class_ = _cast(None, class_)
        self.time_reversal = _cast(bool, time_reversal)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoType.subclass:
            return infoType.subclass(*args_, **kwargs_)
        else:
            return infoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_time_reversal(self): return self.time_reversal
    def set_time_reversal(self, time_reversal): self.time_reversal = time_reversal
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='infoType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='infoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='infoType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
        if self.time_reversal is not None and 'time_reversal' not in already_processed:
            already_processed.add('time_reversal')
            outfile.write(' time_reversal="%s"' % self.gds_format_boolean(self.time_reversal, input_name='time_reversal'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='infoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        value = find_attr_value_('time_reversal', node)
        if value is not None and 'time_reversal' not in already_processed:
            already_processed.add('time_reversal')
            if value in ('true', '1'):
                self.time_reversal = True
            elif value in ('false', '0'):
                self.time_reversal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class infoType


class outputPBCType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, assume_isolated=None):
        self.original_tagname_ = None
        self.assume_isolated = assume_isolated
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, outputPBCType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if outputPBCType.subclass:
            return outputPBCType.subclass(*args_, **kwargs_)
        else:
            return outputPBCType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assume_isolated(self): return self.assume_isolated
    def set_assume_isolated(self, assume_isolated): self.assume_isolated = assume_isolated
    def hasContent_(self):
        if (
            self.assume_isolated is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='outputPBCType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('outputPBCType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='outputPBCType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='outputPBCType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='outputPBCType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='outputPBCType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.assume_isolated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:assume_isolated>%s</qes:assume_isolated>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.assume_isolated), input_name='assume_isolated')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'assume_isolated':
            assume_isolated_ = child_.text
            assume_isolated_ = self.gds_validate_string(assume_isolated_, node, 'assume_isolated')
            self.assume_isolated = assume_isolated_
# end class outputPBCType


class magnetizationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lsda=None, noncolin=None, spinorbit=None, total=None, absolute=None, do_magnetization=None):
        self.original_tagname_ = None
        self.lsda = lsda
        self.noncolin = noncolin
        self.spinorbit = spinorbit
        self.total = total
        self.absolute = absolute
        self.do_magnetization = do_magnetization
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, magnetizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if magnetizationType.subclass:
            return magnetizationType.subclass(*args_, **kwargs_)
        else:
            return magnetizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lsda(self): return self.lsda
    def set_lsda(self, lsda): self.lsda = lsda
    def get_noncolin(self): return self.noncolin
    def set_noncolin(self, noncolin): self.noncolin = noncolin
    def get_spinorbit(self): return self.spinorbit
    def set_spinorbit(self, spinorbit): self.spinorbit = spinorbit
    def get_total(self): return self.total
    def set_total(self, total): self.total = total
    def get_absolute(self): return self.absolute
    def set_absolute(self, absolute): self.absolute = absolute
    def get_do_magnetization(self): return self.do_magnetization
    def set_do_magnetization(self, do_magnetization): self.do_magnetization = do_magnetization
    def hasContent_(self):
        if (
            self.lsda is not None or
            self.noncolin is not None or
            self.spinorbit is not None or
            self.total is not None or
            self.absolute is not None or
            self.do_magnetization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='magnetizationType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('magnetizationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='magnetizationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='magnetizationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='magnetizationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='magnetizationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lsda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:lsda>%s</qes:lsda>%s' % (self.gds_format_boolean(self.lsda, input_name='lsda'), eol_))
        if self.noncolin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:noncolin>%s</qes:noncolin>%s' % (self.gds_format_boolean(self.noncolin, input_name='noncolin'), eol_))
        if self.spinorbit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:spinorbit>%s</qes:spinorbit>%s' % (self.gds_format_boolean(self.spinorbit, input_name='spinorbit'), eol_))
        if self.total is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:total>%s</qes:total>%s' % (self.gds_format_double(self.total, input_name='total'), eol_))
        if self.absolute is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:absolute>%s</qes:absolute>%s' % (self.gds_format_double(self.absolute, input_name='absolute'), eol_))
        if self.do_magnetization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:do_magnetization>%s</qes:do_magnetization>%s' % (self.gds_format_boolean(self.do_magnetization, input_name='do_magnetization'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lsda':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'lsda')
            self.lsda = ival_
        elif nodeName_ == 'noncolin':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'noncolin')
            self.noncolin = ival_
        elif nodeName_ == 'spinorbit':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'spinorbit')
            self.spinorbit = ival_
        elif nodeName_ == 'total' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'total')
            self.total = fval_
        elif nodeName_ == 'absolute' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'absolute')
            self.absolute = fval_
        elif nodeName_ == 'do_magnetization':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'do_magnetization')
            self.do_magnetization = ival_
# end class magnetizationType


class total_energyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, etot=None, eband=None, ehart=None, vtxc=None, etxc=None, ewald=None, demet=None, efieldcorr=None, potentiostat_contr=None, gatefield_contr=None):
        self.original_tagname_ = None
        self.etot = etot
        self.eband = eband
        self.ehart = ehart
        self.vtxc = vtxc
        self.etxc = etxc
        self.ewald = ewald
        self.demet = demet
        self.efieldcorr = efieldcorr
        self.potentiostat_contr = potentiostat_contr
        self.gatefield_contr = gatefield_contr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, total_energyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if total_energyType.subclass:
            return total_energyType.subclass(*args_, **kwargs_)
        else:
            return total_energyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_etot(self): return self.etot
    def set_etot(self, etot): self.etot = etot
    def get_eband(self): return self.eband
    def set_eband(self, eband): self.eband = eband
    def get_ehart(self): return self.ehart
    def set_ehart(self, ehart): self.ehart = ehart
    def get_vtxc(self): return self.vtxc
    def set_vtxc(self, vtxc): self.vtxc = vtxc
    def get_etxc(self): return self.etxc
    def set_etxc(self, etxc): self.etxc = etxc
    def get_ewald(self): return self.ewald
    def set_ewald(self, ewald): self.ewald = ewald
    def get_demet(self): return self.demet
    def set_demet(self, demet): self.demet = demet
    def get_efieldcorr(self): return self.efieldcorr
    def set_efieldcorr(self, efieldcorr): self.efieldcorr = efieldcorr
    def get_potentiostat_contr(self): return self.potentiostat_contr
    def set_potentiostat_contr(self, potentiostat_contr): self.potentiostat_contr = potentiostat_contr
    def get_gatefield_contr(self): return self.gatefield_contr
    def set_gatefield_contr(self, gatefield_contr): self.gatefield_contr = gatefield_contr
    def hasContent_(self):
        if (
            self.etot is not None or
            self.eband is not None or
            self.ehart is not None or
            self.vtxc is not None or
            self.etxc is not None or
            self.ewald is not None or
            self.demet is not None or
            self.efieldcorr is not None or
            self.potentiostat_contr is not None or
            self.gatefield_contr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='total_energyType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('total_energyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='total_energyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='total_energyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='total_energyType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='total_energyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.etot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:etot>%s</qes:etot>%s' % (self.gds_format_double(self.etot, input_name='etot'), eol_))
        if self.eband is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:eband>%s</qes:eband>%s' % (self.gds_format_double(self.eband, input_name='eband'), eol_))
        if self.ehart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ehart>%s</qes:ehart>%s' % (self.gds_format_double(self.ehart, input_name='ehart'), eol_))
        if self.vtxc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:vtxc>%s</qes:vtxc>%s' % (self.gds_format_double(self.vtxc, input_name='vtxc'), eol_))
        if self.etxc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:etxc>%s</qes:etxc>%s' % (self.gds_format_double(self.etxc, input_name='etxc'), eol_))
        if self.ewald is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:ewald>%s</qes:ewald>%s' % (self.gds_format_double(self.ewald, input_name='ewald'), eol_))
        if self.demet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:demet>%s</qes:demet>%s' % (self.gds_format_double(self.demet, input_name='demet'), eol_))
        if self.efieldcorr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:efieldcorr>%s</qes:efieldcorr>%s' % (self.gds_format_double(self.efieldcorr, input_name='efieldcorr'), eol_))
        if self.potentiostat_contr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:potentiostat_contr>%s</qes:potentiostat_contr>%s' % (self.gds_format_double(self.potentiostat_contr, input_name='potentiostat_contr'), eol_))
        if self.gatefield_contr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:gatefield_contr>%s</qes:gatefield_contr>%s' % (self.gds_format_double(self.gatefield_contr, input_name='gatefield_contr'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'etot' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'etot')
            self.etot = fval_
        elif nodeName_ == 'eband' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'eband')
            self.eband = fval_
        elif nodeName_ == 'ehart' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ehart')
            self.ehart = fval_
        elif nodeName_ == 'vtxc' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vtxc')
            self.vtxc = fval_
        elif nodeName_ == 'etxc' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'etxc')
            self.etxc = fval_
        elif nodeName_ == 'ewald' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ewald')
            self.ewald = fval_
        elif nodeName_ == 'demet' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'demet')
            self.demet = fval_
        elif nodeName_ == 'efieldcorr' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'efieldcorr')
            self.efieldcorr = fval_
        elif nodeName_ == 'potentiostat_contr' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'potentiostat_contr')
            self.potentiostat_contr = fval_
        elif nodeName_ == 'gatefield_contr' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'gatefield_contr')
            self.gatefield_contr = fval_
# end class total_energyType


class band_structureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lsda=None, noncolin=None, spinorbit=None, nbnd=None, nbnd_up=None, nbnd_dw=None, nelec=None, num_of_atomic_wfc=None, wf_collected=None, fermi_energy=None, highestOccupiedLevel=None, two_fermi_energies=None, starting_k_points=None, nks=None, occupations_kind=None, smearing=None, ks_energies=None):
        self.original_tagname_ = None
        self.lsda = lsda
        self.noncolin = noncolin
        self.spinorbit = spinorbit
        self.nbnd = nbnd
        self.nbnd_up = nbnd_up
        self.nbnd_dw = nbnd_dw
        self.nelec = nelec
        self.num_of_atomic_wfc = num_of_atomic_wfc
        self.wf_collected = wf_collected
        self.fermi_energy = fermi_energy
        self.highestOccupiedLevel = highestOccupiedLevel
        self.two_fermi_energies = two_fermi_energies
        self.validate_d2vectorType(self.two_fermi_energies)
        self.starting_k_points = starting_k_points
        self.nks = nks
        self.occupations_kind = occupations_kind
        self.smearing = smearing
        if ks_energies is None:
            self.ks_energies = []
        else:
            self.ks_energies = ks_energies
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, band_structureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if band_structureType.subclass:
            return band_structureType.subclass(*args_, **kwargs_)
        else:
            return band_structureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lsda(self): return self.lsda
    def set_lsda(self, lsda): self.lsda = lsda
    def get_noncolin(self): return self.noncolin
    def set_noncolin(self, noncolin): self.noncolin = noncolin
    def get_spinorbit(self): return self.spinorbit
    def set_spinorbit(self, spinorbit): self.spinorbit = spinorbit
    def get_nbnd(self): return self.nbnd
    def set_nbnd(self, nbnd): self.nbnd = nbnd
    def get_nbnd_up(self): return self.nbnd_up
    def set_nbnd_up(self, nbnd_up): self.nbnd_up = nbnd_up
    def get_nbnd_dw(self): return self.nbnd_dw
    def set_nbnd_dw(self, nbnd_dw): self.nbnd_dw = nbnd_dw
    def get_nelec(self): return self.nelec
    def set_nelec(self, nelec): self.nelec = nelec
    def get_num_of_atomic_wfc(self): return self.num_of_atomic_wfc
    def set_num_of_atomic_wfc(self, num_of_atomic_wfc): self.num_of_atomic_wfc = num_of_atomic_wfc
    def get_wf_collected(self): return self.wf_collected
    def set_wf_collected(self, wf_collected): self.wf_collected = wf_collected
    def get_fermi_energy(self): return self.fermi_energy
    def set_fermi_energy(self, fermi_energy): self.fermi_energy = fermi_energy
    def get_highestOccupiedLevel(self): return self.highestOccupiedLevel
    def set_highestOccupiedLevel(self, highestOccupiedLevel): self.highestOccupiedLevel = highestOccupiedLevel
    def get_two_fermi_energies(self): return self.two_fermi_energies
    def set_two_fermi_energies(self, two_fermi_energies): self.two_fermi_energies = two_fermi_energies
    def get_starting_k_points(self): return self.starting_k_points
    def set_starting_k_points(self, starting_k_points): self.starting_k_points = starting_k_points
    def get_nks(self): return self.nks
    def set_nks(self, nks): self.nks = nks
    def get_occupations_kind(self): return self.occupations_kind
    def set_occupations_kind(self, occupations_kind): self.occupations_kind = occupations_kind
    def get_smearing(self): return self.smearing
    def set_smearing(self, smearing): self.smearing = smearing
    def get_ks_energies(self): return self.ks_energies
    def set_ks_energies(self, ks_energies): self.ks_energies = ks_energies
    def add_ks_energies(self, value): self.ks_energies.append(value)
    def insert_ks_energies_at(self, index, value): self.ks_energies.insert(index, value)
    def replace_ks_energies_at(self, index, value): self.ks_energies[index] = value
    def validate_d2vectorType(self, value):
        # Validate type d2vectorType, a restriction on double.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on d2vectorType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.lsda is not None or
            self.noncolin is not None or
            self.spinorbit is not None or
            self.nbnd is not None or
            self.nbnd_up is not None or
            self.nbnd_dw is not None or
            self.nelec is not None or
            self.num_of_atomic_wfc is not None or
            self.wf_collected is not None or
            self.fermi_energy is not None or
            self.highestOccupiedLevel is not None or
            self.two_fermi_energies is not None or
            self.starting_k_points is not None or
            self.nks is not None or
            self.occupations_kind is not None or
            self.smearing is not None or
            self.ks_energies
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='band_structureType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('band_structureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='band_structureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='band_structureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='band_structureType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='band_structureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lsda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:lsda>%s</qes:lsda>%s' % (self.gds_format_boolean(self.lsda, input_name='lsda'), eol_))
        if self.noncolin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:noncolin>%s</qes:noncolin>%s' % (self.gds_format_boolean(self.noncolin, input_name='noncolin'), eol_))
        if self.spinorbit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:spinorbit>%s</qes:spinorbit>%s' % (self.gds_format_boolean(self.spinorbit, input_name='spinorbit'), eol_))
        if self.nbnd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nbnd>%s</qes:nbnd>%s' % (self.gds_format_integer(self.nbnd, input_name='nbnd'), eol_))
        if self.nbnd_up is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nbnd_up>%s</qes:nbnd_up>%s' % (self.gds_format_integer(self.nbnd_up, input_name='nbnd_up'), eol_))
        if self.nbnd_dw is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nbnd_dw>%s</qes:nbnd_dw>%s' % (self.gds_format_integer(self.nbnd_dw, input_name='nbnd_dw'), eol_))
        if self.nelec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nelec>%s</qes:nelec>%s' % (self.gds_format_double(self.nelec, input_name='nelec'), eol_))
        if self.num_of_atomic_wfc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:num_of_atomic_wfc>%s</qes:num_of_atomic_wfc>%s' % (self.gds_format_integer(self.num_of_atomic_wfc, input_name='num_of_atomic_wfc'), eol_))
        if self.wf_collected is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:wf_collected>%s</qes:wf_collected>%s' % (self.gds_format_boolean(self.wf_collected, input_name='wf_collected'), eol_))
        if self.fermi_energy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:fermi_energy>%s</qes:fermi_energy>%s' % (self.gds_format_double(self.fermi_energy, input_name='fermi_energy'), eol_))
        if self.highestOccupiedLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:highestOccupiedLevel>%s</qes:highestOccupiedLevel>%s' % (self.gds_format_double(self.highestOccupiedLevel, input_name='highestOccupiedLevel'), eol_))
        if self.two_fermi_energies is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:two_fermi_energies>%s</qes:two_fermi_energies>%s' % (self.gds_format_double_list(self.two_fermi_energies, input_name='two_fermi_energies'), eol_))
        if self.starting_k_points is not None:
            self.starting_k_points.export(outfile, level, namespaceprefix_, name_='starting_k_points', pretty_print=pretty_print)
        if self.nks is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:nks>%s</qes:nks>%s' % (self.gds_format_integer(self.nks, input_name='nks'), eol_))
        if self.occupations_kind is not None:
            self.occupations_kind.export(outfile, level, namespaceprefix_, name_='occupations_kind', pretty_print=pretty_print)
        if self.smearing is not None:
            self.smearing.export(outfile, level, namespaceprefix_, name_='smearing', pretty_print=pretty_print)
        for ks_energies_ in self.ks_energies:
            ks_energies_.export(outfile, level, namespaceprefix_, name_='ks_energies', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lsda':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'lsda')
            self.lsda = ival_
        elif nodeName_ == 'noncolin':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'noncolin')
            self.noncolin = ival_
        elif nodeName_ == 'spinorbit':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'spinorbit')
            self.spinorbit = ival_
        elif nodeName_ == 'nbnd' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nbnd')
            self.nbnd = ival_
        elif nodeName_ == 'nbnd_up' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nbnd_up')
            self.nbnd_up = ival_
        elif nodeName_ == 'nbnd_dw' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nbnd_dw')
            self.nbnd_dw = ival_
        elif nodeName_ == 'nelec' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'nelec')
            self.nelec = fval_
        elif nodeName_ == 'num_of_atomic_wfc' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'num_of_atomic_wfc')
            self.num_of_atomic_wfc = ival_
        elif nodeName_ == 'wf_collected':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'wf_collected')
            self.wf_collected = ival_
        elif nodeName_ == 'fermi_energy' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fermi_energy')
            self.fermi_energy = fval_
        elif nodeName_ == 'highestOccupiedLevel' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'highestOccupiedLevel')
            self.highestOccupiedLevel = fval_
        elif nodeName_ == 'two_fermi_energies':
            two_fermi_energies_ = child_.text
            two_fermi_energies_ = self.gds_validate_double_list(two_fermi_energies_, node, 'two_fermi_energies')
            self.two_fermi_energies = two_fermi_energies_
            # validate type d2vectorType
            self.validate_d2vectorType(self.two_fermi_energies)
        elif nodeName_ == 'starting_k_points':
            obj_ = k_points_IBZType.factory()
            obj_.build(child_)
            self.starting_k_points = obj_
            obj_.original_tagname_ = 'starting_k_points'
        elif nodeName_ == 'nks' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nks')
            self.nks = ival_
        elif nodeName_ == 'occupations_kind':
            obj_ = occupationsType.factory()
            obj_.build(child_)
            self.occupations_kind = obj_
            obj_.original_tagname_ = 'occupations_kind'
        elif nodeName_ == 'smearing':
            obj_ = smearingType.factory()
            obj_.build(child_)
            self.smearing = obj_
            obj_.original_tagname_ = 'smearing'
        elif nodeName_ == 'ks_energies':
            obj_ = ks_energiesType.factory()
            obj_.build(child_)
            self.ks_energies.append(obj_)
            obj_.original_tagname_ = 'ks_energies'
# end class band_structureType


class ks_energiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, k_point=None, npw=None, eigenvalues=None, occupations=None):
        self.original_tagname_ = None
        self.k_point = k_point
        self.npw = npw
        self.eigenvalues = eigenvalues
        self.occupations = occupations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ks_energiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ks_energiesType.subclass:
            return ks_energiesType.subclass(*args_, **kwargs_)
        else:
            return ks_energiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_k_point(self): return self.k_point
    def set_k_point(self, k_point): self.k_point = k_point
    def get_npw(self): return self.npw
    def set_npw(self, npw): self.npw = npw
    def get_eigenvalues(self): return self.eigenvalues
    def set_eigenvalues(self, eigenvalues): self.eigenvalues = eigenvalues
    def get_occupations(self): return self.occupations
    def set_occupations(self, occupations): self.occupations = occupations
    def hasContent_(self):
        if (
            self.k_point is not None or
            self.npw is not None or
            self.eigenvalues is not None or
            self.occupations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='ks_energiesType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ks_energiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ks_energiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='ks_energiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='ks_energiesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='ks_energiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.k_point is not None:
            self.k_point.export(outfile, level, namespaceprefix_, name_='k_point', pretty_print=pretty_print)
        if self.npw is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qes:npw>%s</qes:npw>%s' % (self.gds_format_integer(self.npw, input_name='npw'), eol_))
        if self.eigenvalues is not None:
            self.eigenvalues.export(outfile, level, namespaceprefix_, name_='eigenvalues', pretty_print=pretty_print)
        if self.occupations is not None:
            self.occupations.export(outfile, level, namespaceprefix_, name_='occupations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'k_point':
            obj_ = k_pointType.factory()
            obj_.build(child_)
            self.k_point = obj_
            obj_.original_tagname_ = 'k_point'
        elif nodeName_ == 'npw' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'npw')
            self.npw = ival_
        elif nodeName_ == 'eigenvalues':
            class_obj_ = self.get_class_obj_(child_, vectorType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.eigenvalues = obj_
            obj_.original_tagname_ = 'eigenvalues'
        elif nodeName_ == 'occupations':
            class_obj_ = self.get_class_obj_(child_, vectorType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.occupations = obj_
            obj_.original_tagname_ = 'occupations'
# end class ks_energiesType


class closedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATE=None, TIME=None, valueOf_=None):
        self.original_tagname_ = None
        self.DATE = _cast(None, DATE)
        self.TIME = _cast(None, TIME)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, closedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if closedType.subclass:
            return closedType.subclass(*args_, **kwargs_)
        else:
            return closedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATE(self): return self.DATE
    def set_DATE(self, DATE): self.DATE = DATE
    def get_TIME(self): return self.TIME
    def set_TIME(self, TIME): self.TIME = TIME
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='closedType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('closedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='closedType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='closedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='closedType'):
        if self.DATE is not None and 'DATE' not in already_processed:
            already_processed.add('DATE')
            outfile.write(' DATE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DATE), input_name='DATE')), ))
        if self.TIME is not None and 'TIME' not in already_processed:
            already_processed.add('TIME')
            outfile.write(' TIME=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TIME), input_name='TIME')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='closedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DATE', node)
        if value is not None and 'DATE' not in already_processed:
            already_processed.add('DATE')
            self.DATE = value
        value = find_attr_value_('TIME', node)
        if value is not None and 'TIME' not in already_processed:
            already_processed.add('TIME')
            self.TIME = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class closedType


class vectorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, size=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.size = _cast(int, size)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vectorType.subclass:
            return vectorType.subclass(*args_, **kwargs_)
        else:
            return vectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='vectorType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vectorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='vectorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='vectorType'):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='vectorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vectorType


class integerVectorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, size=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.size = _cast(int, size)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, integerVectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if integerVectorType.subclass:
            return integerVectorType.subclass(*args_, **kwargs_)
        else:
            return integerVectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='integerVectorType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('integerVectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='integerVectorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='integerVectorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='integerVectorType'):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='integerVectorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class integerVectorType


class matrixType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rank=None, dims=None, order=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.rank = _cast(int, rank)
        self.dims = _cast(int, dims)
        self.order = _cast(None, order)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, matrixType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if matrixType.subclass:
            return matrixType.subclass(*args_, **kwargs_)
        else:
            return matrixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rank(self): return self.rank
    def set_rank(self, rank): self.rank = rank
    def get_dims(self): return self.dims
    def set_dims(self, dims): self.dims = dims
    def get_order(self): return self.order
    def set_order(self, order): self.order = order
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='matrixType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('matrixType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='matrixType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='matrixType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='matrixType'):
        if self.rank is not None and 'rank' not in already_processed:
            already_processed.add('rank')
            outfile.write(' rank="%s"' % self.gds_format_integer(self.rank, input_name='rank'))
        if self.dims is not None and 'dims' not in already_processed:
            already_processed.add('dims')
            outfile.write(' dims=%s' % (quote_attrib(self.dims), ))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.order), input_name='order')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='matrixType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rank', node)
        if value is not None and 'rank' not in already_processed:
            already_processed.add('rank')
            try:
                self.rank = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.rank <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('dims', node)
        if value is not None and 'dims' not in already_processed:
            already_processed.add('dims')
            self.dims = value
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class matrixType


class integerMatrixType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rank=None, dims=None, order=None, valueOf_=None):
        self.original_tagname_ = None
        self.rank = _cast(int, rank)
        self.dims = _cast(int, dims)
        self.order = _cast(None, order)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, integerMatrixType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if integerMatrixType.subclass:
            return integerMatrixType.subclass(*args_, **kwargs_)
        else:
            return integerMatrixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rank(self): return self.rank
    def set_rank(self, rank): self.rank = rank
    def get_dims(self): return self.dims
    def set_dims(self, dims): self.dims = dims
    def get_order(self): return self.order
    def set_order(self, order): self.order = order
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='integerMatrixType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('integerMatrixType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='integerMatrixType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='integerMatrixType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='integerMatrixType'):
        if self.rank is not None and 'rank' not in already_processed:
            already_processed.add('rank')
            outfile.write(' rank="%s"' % self.gds_format_integer(self.rank, input_name='rank'))
        if self.dims is not None and 'dims' not in already_processed:
            already_processed.add('dims')
            outfile.write(' dims=%s' % (quote_attrib(self.dims), ))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.order), input_name='order')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='integerMatrixType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rank', node)
        if value is not None and 'rank' not in already_processed:
            already_processed.add('rank')
            try:
                self.rank = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.rank <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('dims', node)
        if value is not None and 'dims' not in already_processed:
            already_processed.add('dims')
            self.dims = value
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class integerMatrixType


class scalarQuantityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Units=None, valueOf_=None):
        self.original_tagname_ = None
        self.Units = _cast(None, Units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scalarQuantityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scalarQuantityType.subclass:
            return scalarQuantityType.subclass(*args_, **kwargs_)
        else:
            return scalarQuantityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='scalarQuantityType', namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scalarQuantityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scalarQuantityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='scalarQuantityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='scalarQuantityType'):
        if self.Units is not None and 'Units' not in already_processed:
            already_processed.add('Units')
            outfile.write(' Units=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Units), input_name='Units')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='scalarQuantityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Units', node)
        if value is not None and 'Units' not in already_processed:
            already_processed.add('Units')
            self.Units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class scalarQuantityType


class equivalent_atomsType(integerVectorType):
    subclass = None
    superclass = integerVectorType
    def __init__(self, size=None, nat=None, valueOf_=None):
        self.original_tagname_ = None
        super(equivalent_atomsType, self).__init__(size, valueOf_, )
        self.nat = _cast(int, nat)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, equivalent_atomsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if equivalent_atomsType.subclass:
            return equivalent_atomsType.subclass(*args_, **kwargs_)
        else:
            return equivalent_atomsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nat(self): return self.nat
    def set_nat(self, nat): self.nat = nat
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(equivalent_atomsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='equivalent_atomsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('equivalent_atomsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='equivalent_atomsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='equivalent_atomsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='equivalent_atomsType'):
        super(equivalent_atomsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='equivalent_atomsType')
        if self.nat is not None and 'nat' not in already_processed:
            already_processed.add('nat')
            outfile.write(' nat="%s"' % self.gds_format_integer(self.nat, input_name='nat'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='equivalent_atomsType', fromsubclass_=False, pretty_print=True):
        super(equivalent_atomsType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nat', node)
        if value is not None and 'nat' not in already_processed:
            already_processed.add('nat')
            try:
                self.nat = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.nat <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(equivalent_atomsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class equivalent_atomsType


class inputOccupationsType(vectorType):
    subclass = None
    superclass = vectorType
    def __init__(self, size=None, ispin=None, spin_factor=None, valueOf_=None):
        self.original_tagname_ = None
        super(inputOccupationsType, self).__init__(size, valueOf_, )
        self.ispin = _cast(int, ispin)
        self.spin_factor = _cast(float, spin_factor)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, inputOccupationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if inputOccupationsType.subclass:
            return inputOccupationsType.subclass(*args_, **kwargs_)
        else:
            return inputOccupationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ispin(self): return self.ispin
    def set_ispin(self, ispin): self.ispin = ispin
    def get_spin_factor(self): return self.spin_factor
    def set_spin_factor(self, spin_factor): self.spin_factor = spin_factor
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(inputOccupationsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='inputOccupationsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('inputOccupationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='inputOccupationsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='inputOccupationsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='inputOccupationsType'):
        super(inputOccupationsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='inputOccupationsType')
        if self.ispin is not None and 'ispin' not in already_processed:
            already_processed.add('ispin')
            outfile.write(' ispin="%s"' % self.gds_format_integer(self.ispin, input_name='ispin'))
        if self.spin_factor is not None and 'spin_factor' not in already_processed:
            already_processed.add('spin_factor')
            outfile.write(' spin_factor="%s"' % self.gds_format_double(self.spin_factor, input_name='spin_factor'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='inputOccupationsType', fromsubclass_=False, pretty_print=True):
        super(inputOccupationsType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ispin', node)
        if value is not None and 'ispin' not in already_processed:
            already_processed.add('ispin')
            try:
                self.ispin = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ispin <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('spin_factor', node)
        if value is not None and 'spin_factor' not in already_processed:
            already_processed.add('spin_factor')
            try:
                self.spin_factor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (spin_factor): %s' % exp)
        super(inputOccupationsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class inputOccupationsType


class Hubbard_nsType(matrixType):
    subclass = None
    superclass = matrixType
    def __init__(self, rank=None, dims=None, order=None, specie=None, label=None, spin=None, index=None, valueOf_=None):
        self.original_tagname_ = None
        super(Hubbard_nsType, self).__init__(rank, dims, order, valueOf_, )
        self.specie = _cast(None, specie)
        self.label = _cast(None, label)
        self.spin = _cast(int, spin)
        self.index = _cast(int, index)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Hubbard_nsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Hubbard_nsType.subclass:
            return Hubbard_nsType.subclass(*args_, **kwargs_)
        else:
            return Hubbard_nsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_specie(self): return self.specie
    def set_specie(self, specie): self.specie = specie
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_spin(self): return self.spin
    def set_spin(self, spin): self.spin = spin
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Hubbard_nsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='Hubbard_nsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Hubbard_nsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Hubbard_nsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='Hubbard_nsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='Hubbard_nsType'):
        super(Hubbard_nsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Hubbard_nsType')
        if self.specie is not None and 'specie' not in already_processed:
            already_processed.add('specie')
            outfile.write(' specie=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.specie), input_name='specie')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.spin is not None and 'spin' not in already_processed:
            already_processed.add('spin')
            outfile.write(' spin="%s"' % self.gds_format_integer(self.spin, input_name='spin'))
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='Hubbard_nsType', fromsubclass_=False, pretty_print=True):
        super(Hubbard_nsType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('specie', node)
        if value is not None and 'specie' not in already_processed:
            already_processed.add('specie')
            self.specie = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('spin', node)
        if value is not None and 'spin' not in already_processed:
            already_processed.add('spin')
            try:
                self.spin = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.spin <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            try:
                self.index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.index <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(Hubbard_nsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Hubbard_nsType


class starting_nsType(vectorType):
    subclass = None
    superclass = vectorType
    def __init__(self, size=None, specie=None, label=None, spin=None, valueOf_=None):
        self.original_tagname_ = None
        super(starting_nsType, self).__init__(size, valueOf_, )
        self.specie = _cast(None, specie)
        self.label = _cast(None, label)
        self.spin = _cast(int, spin)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, starting_nsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if starting_nsType.subclass:
            return starting_nsType.subclass(*args_, **kwargs_)
        else:
            return starting_nsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_specie(self): return self.specie
    def set_specie(self, specie): self.specie = specie
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_spin(self): return self.spin
    def set_spin(self, spin): self.spin = spin
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(starting_nsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='qes:', name_='starting_nsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('starting_nsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='starting_nsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='qes:', name_='starting_nsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='qes:', name_='starting_nsType'):
        super(starting_nsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='starting_nsType')
        if self.specie is not None and 'specie' not in already_processed:
            already_processed.add('specie')
            outfile.write(' specie=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.specie), input_name='specie')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.spin is not None and 'spin' not in already_processed:
            already_processed.add('spin')
            outfile.write(' spin="%s"' % self.gds_format_integer(self.spin, input_name='spin'))
    def exportChildren(self, outfile, level, namespaceprefix_='qes:', name_='starting_nsType', fromsubclass_=False, pretty_print=True):
        super(starting_nsType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('specie', node)
        if value is not None and 'specie' not in already_processed:
            already_processed.add('specie')
            self.specie = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('spin', node)
        if value is not None and 'spin' not in already_processed:
            already_processed.add('spin')
            try:
                self.spin = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.spin <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(starting_nsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class starting_nsType


GDSClassesMapping = {
    'espresso': espressoType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'espressoType'
        rootClass = espressoType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'espressoType'
        rootClass = espressoType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'espressoType'
        rootClass = espressoType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:qes="http://www.quantum-espresso.org/ns/qes/qes-1.0"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'espressoType'
        rootClass = espressoType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from qes-1.0 import *\n\n')
        sys.stdout.write('import qes-1.0 as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "BerryPhaseOutputType",
    "HubbardCommonType",
    "HubbardJType",
    "Hubbard_nsType",
    "algorithmic_infoType",
    "atomType",
    "atomic_constraintType",
    "atomic_constraintsType",
    "atomic_positionsType",
    "atomic_speciesType",
    "atomic_structureType",
    "band_structureType",
    "bandsType",
    "basisSetItemType",
    "basisType",
    "basis_setType",
    "bfgsType",
    "boundary_conditionsType",
    "cellType",
    "cell_controlType",
    "closedType",
    "control_variablesType",
    "convergence_infoType",
    "createdType",
    "creatorType",
    "dftType",
    "dftUType",
    "dipoleOutputType",
    "ekin_functionalType",
    "electric_fieldType",
    "electron_controlType",
    "electronicPolarizationType",
    "equivalent_atomsType",
    "esmType",
    "espressoType",
    "finiteFieldOutType",
    "gateInfoType",
    "gate_settingsType",
    "general_infoType",
    "hybridType",
    "infoType",
    "inputOccupationsType",
    "inputType",
    "integerMatrixType",
    "integerVectorType",
    "ion_controlType",
    "ionicPolarizationType",
    "k_pointType",
    "k_points_IBZType",
    "ks_energiesType",
    "magnetizationType",
    "matrixType",
    "mdType",
    "monkhorst_packType",
    "occupationsType",
    "opt_convType",
    "outputElectricFieldType",
    "outputPBCType",
    "outputType",
    "parallel_infoType",
    "phaseType",
    "polarizationType",
    "qpoint_gridType",
    "reciprocal_latticeType",
    "scalarQuantityType",
    "scf_convType",
    "smearingType",
    "speciesType",
    "spinType",
    "spin_constraintsType",
    "starting_nsType",
    "stepType",
    "symmetriesType",
    "symmetryType",
    "symmetry_flagsType",
    "total_energyType",
    "vdWType",
    "vectorType",
    "wyckoff_positionsType",
    "xml_formatType"
]
